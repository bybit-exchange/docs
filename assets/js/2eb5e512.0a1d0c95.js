"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[4204],{3905:(e,n,t)=>{t.d(n,{Zo:()=>f,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},f=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,f=o(e,["components","mdxType","originalType","parentName"]),d=p(t),m=a,c=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?r.createElement(c,l(l({ref:n},f),{},{components:t})):r.createElement(c,l({ref:n},f))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4756:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=t(87462),a=(t(67294),t(3905));const i={title:"SBE Public Trade Integration",sidebar_label:"SBE Public Trade Integration",sidebar_position:3},l=void 0,o={unversionedId:"v5/sbe/sbe-public-trade/sbe-public-trade",id:"v5/sbe/sbe-public-trade/sbe-public-trade",title:"SBE Public Trade Integration",description:"Overview",source:"@site/docs/v5/sbe/sbe-public-trade/sbe-public-trade.mdx",sourceDirName:"v5/sbe/sbe-public-trade",slug:"/v5/sbe/sbe-public-trade/",permalink:"/docs/v5/sbe/sbe-public-trade/",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"SBE Public Trade Integration",sidebar_label:"SBE Public Trade Integration",sidebar_position:3},sidebar:"v5SideBar",previous:{title:"SBE Level 50 Integration",permalink:"/docs/v5/sbe/level-50/sbe-level-50"},next:{title:"Connect",permalink:"/docs/v5/ws/connect"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Flow",id:"flow",level:2},{value:"Ping / Pong (JSON control frames)",id:"ping--pong-json-control-frames",level:3},{value:"Subscribe",id:"subscribe",level:3},{value:"SBE XML Template (Public Trade)",id:"sbe-xml-template-public-trade",level:2},{value:"Field Reference",id:"field-reference",level:2},{value:"Each tradeItemsi entry",id:"each-tradeitemsi-entry",level:3},{value:"SideType",id:"sidetype",level:4},{value:"BoolEnum",id:"boolenum",level:4},{value:"Integration Script",id:"integration-script",level:2},{value:"Python",id:"python",level:3},{value:"Golang",id:"golang",level:3}],f={toc:p};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Channel:")," private MMWS only (not available on public WS)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"WSURL:")," ",(0,a.kt)("inlineCode",{parentName:"li"},"wss://<your-public-stream-host>.bybit-aws.com/v5/public-sbe/<category>"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Topic:")," ",(0,a.kt)("inlineCode",{parentName:"li"},"publicTrade.sbe.<symbol>"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Format:")," SBE binary frames (",(0,a.kt)("inlineCode",{parentName:"li"},"opcode = 2"),"), little-endian."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Push frequency"),": real-time"),(0,a.kt)("li",{parentName:"ul"},"Messages are delivered in-order per symbol group. A single packet may contain 1\u20131024 trades")),(0,a.kt)("h2",{id:"flow"},"Flow"),(0,a.kt)("h3",{id:"ping--pong-json-control-frames"},"Ping / Pong (JSON control frames)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Send Ping")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{"req_id": "100001", "op": "ping"}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Receive Pong")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{"success": true,"ret_msg": "pong","conn_id": "xxxxx-xx","req_id": "","op": "ping"}\n')),(0,a.kt)("h3",{id:"subscribe"},"Subscribe"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Topic format: ",(0,a.kt)("inlineCode",{parentName:"li"},"publicTrade.sbe.<symbol>"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Subscribe request")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{"op": "subscribe","req_id":"100001","args": ["publicTrade.sbe.BTCUSDT"]}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Subscription confirmation")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{"success":true,"ret_msg":"","conn_id":"d5phu6rboasumi7uds7g-223s","req_id":"100001","op":"subscribe"}\n')),(0,a.kt)("h2",{id:"sbe-xml-template-public-trade"},"SBE XML Template (Public Trade)"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"../sbe/sbe-basic-info#sbe-xml-template"},"sbe xml template")),(0,a.kt)("h2",{id:"field-reference"},"Field Reference"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Message:")," ",(0,a.kt)("inlineCode",{parentName:"p"},"PublicTradeEvent")," (id = 20002)"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Field Name"),(0,a.kt)("th",{parentName:"tr",align:null},"ID"),(0,a.kt)("th",{parentName:"tr",align:null},"SBE Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Unit / Format"),(0,a.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"ts"),(0,a.kt)("td",{parentName:"tr",align:null},"1"),(0,a.kt)("td",{parentName:"tr",align:null},"int64"),(0,a.kt)("td",{parentName:"tr",align:null},"\xb5s"),(0,a.kt)("td",{parentName:"tr",align:null},"System generation time at market data service.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"priceExponent"),(0,a.kt)("td",{parentName:"tr",align:null},"2"),(0,a.kt)("td",{parentName:"tr",align:null},"int8"),(0,a.kt)("td",{parentName:"tr",align:null},"exponent"),(0,a.kt)("td",{parentName:"tr",align:null},"Decimal places for price. Display price = priceMantissa \xd7 10^",(0,a.kt)("inlineCode",{parentName:"td"},"priceExponent"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sizeExponent"),(0,a.kt)("td",{parentName:"tr",align:null},"3"),(0,a.kt)("td",{parentName:"tr",align:null},"int8"),(0,a.kt)("td",{parentName:"tr",align:null},"exponent"),(0,a.kt)("td",{parentName:"tr",align:null},"Decimal places for size. Display size = sizeMantissa \xd7 10^",(0,a.kt)("inlineCode",{parentName:"td"},"sizeExponent"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"tradeItems"),(0,a.kt)("td",{parentName:"tr",align:null},"40"),(0,a.kt)("td",{parentName:"tr",align:null},"group(",(0,a.kt)("inlineCode",{parentName:"td"},"groupSize16Encoding"),")"),(0,a.kt)("td",{parentName:"tr",align:null},"-"),(0,a.kt)("td",{parentName:"tr",align:null},"Repeating trade items")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"symbol"),(0,a.kt)("td",{parentName:"tr",align:null},"55"),(0,a.kt)("td",{parentName:"tr",align:null},"varString8"),(0,a.kt)("td",{parentName:"tr",align:null},"UTF-8"),(0,a.kt)("td",{parentName:"tr",align:null},"1-byte length + bytes, e.g., ",(0,a.kt)("inlineCode",{parentName:"td"},'0x07 "BTCUSDT"'),".")))),(0,a.kt)("h3",{id:"each-tradeitemsi-entry"},"Each tradeItems","[i]"," entry"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Field (id)"),(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"fillTime (1)"),(0,a.kt)("td",{parentName:"tr",align:null},"int64"),(0,a.kt)("td",{parentName:"tr",align:null},"Trade fill timestamp(\xb5s)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"price  (2)"),(0,a.kt)("td",{parentName:"tr",align:null},"int64"),(0,a.kt)("td",{parentName:"tr",align:null},"Apply priceExponent. Display ask size  = ",(0,a.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"size  (3)"),(0,a.kt)("td",{parentName:"tr",align:null},"int64"),(0,a.kt)("td",{parentName:"tr",align:null},"Apply sizeExponent. Display ask size  = ",(0,a.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"seq  (4)"),(0,a.kt)("td",{parentName:"tr",align:null},"int64"),(0,a.kt)("td",{parentName:"tr",align:null},"Cross sequence id")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"side  (5)"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"#sidetype"},"SideType"),"(uint8)"),(0,a.kt)("td",{parentName:"tr",align:null},"Side of taker")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"isBlockTrade  (6)"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"#boolenum"},"BoolEnum"),"(uint8)"),(0,a.kt)("td",{parentName:"tr",align:null},"IsBlockTrade(0 = not blockTrade, 1 = blockTrade)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"isRPI  (7)"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"#boolenum"},"BoolEnum"),"(uint8)"),(0,a.kt)("td",{parentName:"tr",align:null},"IsRPI (0 = not RPI, 1 = RPI)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"execId  (8)"),(0,a.kt)("td",{parentName:"tr",align:null},"int64"),(0,a.kt)("td",{parentName:"tr",align:null},"Trade ID")))),(0,a.kt)("h4",{id:"sidetype"},"SideType"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0"),": UNKOWN"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1"),": BUY"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"2"),": SELL"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"254"),": NON_REPRESENTABLE")),(0,a.kt)("h4",{id:"boolenum"},"BoolEnum"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0"),": FALSE"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1"),": TRUE"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"254"),": NON_REPRESENTABLE")),(0,a.kt)("h2",{id:"integration-script"},"Integration Script"),(0,a.kt)("h3",{id:"python"},"Python"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import json\nimport struct\nimport websocket\nfrom typing import Tuple\n\nWS_URL = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\nSYMBOL = "BTCUSDT"\nTOPIC = f"publicTrade.sbe.{SYMBOL}"\n\n\n# ---------------- SBE helpers ----------------\ndef apply_exp(mantissa: int, exp: int) -> float:\n    # display = mantissa * 10^exp\n    # exp can be negative\n    return mantissa * (10.0**exp)\n\n\ndef read_varstring8(buf: bytes, off: int) -> Tuple[str, int]:\n    if off + 1 > len(buf):\n        raise ValueError("varString8: missing length")\n\n    ln = buf[off]\n    off += 1\n\n    if off + ln > len(buf):\n        raise ValueError("varString8: out of range")\n\n    s = buf[off : off + ln].decode("utf-8", errors="replace")\n    off += ln\n    return s, off\n\n\ndef parse_public_trade_event(buf: bytes) -> dict:\n    # messageHeader: <HHHH\n    if len(buf) < 8:\n        raise ValueError("too short for header")\n\n    block_len, template_id, schema_id, version = struct.unpack_from("<HHHH", buf, 0)\n    off = 8\n\n    if template_id != 20002:\n        raise ValueError(f"unexpected templateId={template_id}")\n\n    # fixed fields: ts(int64), priceExp(int8), sizeExp(int8)\n    if len(buf) < off + 8 + 1 + 1:\n        raise ValueError("too short for fixed fields")\n\n    ts = struct.unpack_from("<q", buf, off)[0]\n    off += 8\n\n    price_exp = struct.unpack_from("<b", buf, off)[0]\n    off += 1\n\n    size_exp = struct.unpack_from("<b", buf, off)[0]\n    off += 1\n\n    # group header: blockLength(uint16), numInGroup(uint16)\n    if len(buf) < off + 4:\n        raise ValueError("too short for group header")\n\n    grp_block_len, num_in_group = struct.unpack_from("<HH", buf, off)\n    off += 4\n\n    trades = []\n    for _ in range(num_in_group):\n        entry_start = off\n\n        # Parse fields in-order (don\u2019t assume padding; only skip remaining bytes up to grp_block_len)\n        fill_time = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        price_m = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        size_m = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        seq = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        side = struct.unpack_from("<B", buf, off)[0]\n        off += 1\n\n        is_block = struct.unpack_from("<B", buf, off)[0]\n        off += 1\n\n        is_rpi = struct.unpack_from("<B", buf, off)[0]\n        off += 1\n\n        # Skip any future extension bytes in fixed part\n        fixed_consumed = off - entry_start\n        if fixed_consumed < grp_block_len:\n            off += grp_block_len - fixed_consumed\n        elif fixed_consumed > grp_block_len:\n            # schema mismatch vs blockLength\n            raise ValueError(\n                f"group blockLength too small: {grp_block_len} < {fixed_consumed}"\n            )\n        exec_id, off = read_varstring8(buf, off)\n        trades.append(\n            {\n                "fillTime": fill_time,\n                "priceMantissa": price_m,\n                "sizeMantissa": size_m,\n                "price": apply_exp(price_m, price_exp),\n                "size": apply_exp(size_m, size_exp),\n                "seq": seq,\n                "side": side,\n                "isBlockTrade": bool(is_block),\n                "isRPI": bool(is_rpi),\n                "execId": exec_id,\n            }\n        )\n\n    symbol, off = read_varstring8(buf, off)\n\n    return {\n        "header": {\n            "blockLength": block_len,\n            "templateId": template_id,\n            "schemaId": schema_id,\n            "version": version,\n        },\n        "ts": ts,\n        "priceExponent": price_exp,\n        "sizeExponent": size_exp,\n        "symbol": symbol,\n        "tradeItems": trades,\n        "parsed_length": off,\n    }\n\n\n# ---------------- WS handlers ----------------\ndef on_open(ws):\n    ws.send(json.dumps({"op": "subscribe", "args": [TOPIC]}))\n    print("subscribed:", TOPIC)\n\n\ndef on_message(ws, message):\n    if isinstance(message, (bytes, bytearray)):\n        evt = parse_public_trade_event(message)\n\n        # print first trade only (example)\n        if evt["tradeItems"]:\n            t0 = evt["tradeItems"][0]\n            print(\n                evt["symbol"],\n                "trades=",\n                len(evt["tradeItems"]),\n                "first:",\n                t0["price"],\n                "@",\n                t0["size"],\n                "seq=",\n                t0["seq"],\n            )\n    else:\n        print("TEXT:", message)\n\n\ndef on_error(ws, err):\n    print("WS error:", err)\n\n\ndef on_close(ws, *_):\n    print("closed")\n\n\nif __name__ == "__main__":\n    websocket.enableTrace(False)\n    ws = websocket.WebSocketApp(\n        WS_URL,\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n    )\n    ws.run_forever(ping_interval=20, ping_timeout=10)\n')),(0,a.kt)("h3",{id:"golang"},"Golang"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n        "encoding/binary"\n        "encoding/json"\n        "fmt"\n        "log"\n        "math"\n        "time"\n\n        "github.com/gorilla/websocket"\n)\n\nconst (\n        WSURL  = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\n        Symbol = "BTCUSDT"\n        Topic  = "publicTrade.sbe." + Symbol\n)\n\nfunc applyExp(mantissa int64, exp int8) float64 {\n        return float64(mantissa) * math.Pow10(int(exp))\n}\n\nfunc readVarString8(buf []byte, off int) (string, int, error) {\n        if off+1 > len(buf) {\n                return "", off, fmt.Errorf("varString8: missing length")\n        }\n        ln := int(buf[off])\n        off++\n        if off+ln > len(buf) {\n                return "", off, fmt.Errorf("varString8: out of range")\n        }\n        s := string(buf[off : off+ln])\n        off += ln\n        return s, off, nil\n}\n\ntype TradeItem struct {\n        FillTime     int64   `json:"fillTime"`\n        PriceMant    int64   `json:"priceMantissa"`\n        SizeMant     int64   `json:"sizeMantissa"`\n        Price        float64 `json:"price"`\n        Size         float64 `json:"size"`\n        Seq          int64   `json:"seq"`\n        Side         uint8   `json:"side"`\n        IsBlockTrade bool    `json:"isBlockTrade"`\n        IsRPI        bool    `json:"isRPI"`\n        ExecID       string   `json:"execId"`\n}\n\ntype PublicTradeEvent struct {\n        Header struct {\n                BlockLength uint16 `json:"blockLength"`\n                TemplateID  uint16 `json:"templateId"`\n                SchemaID    uint16 `json:"schemaId"`\n                Version     uint16 `json:"version"`\n        } `json:"header"`\n\n        Ts            int64       `json:"ts"`\n        PriceExponent int8        `json:"priceExponent"`\n        SizeExponent  int8        `json:"sizeExponent"`\n        TradeItems    []TradeItem `json:"tradeItems"`\n        Symbol        string      `json:"symbol"`\n        ParsedLength  int         `json:"parsed_length"`\n}\n\nfunc parsePublicTradeEvent(buf []byte) (*PublicTradeEvent, error) {\n        if len(buf) < 8 {\n                return nil, fmt.Errorf("too short for header")\n        }\n        off := 0\n        blk := binary.LittleEndian.Uint16(buf[off : off+2])\n        tid := binary.LittleEndian.Uint16(buf[off+2 : off+4])\n        sid := binary.LittleEndian.Uint16(buf[off+4 : off+6])\n        ver := binary.LittleEndian.Uint16(buf[off+6 : off+8])\n        off += 8\n\n        if tid != 20002 {\n                return nil, fmt.Errorf("unexpected templateId=%d", tid)\n        }\n        if off+8+1+1 > len(buf) {\n                return nil, fmt.Errorf("too short for fixed fields")\n        }\n        ts := int64(binary.LittleEndian.Uint64(buf[off : off+8]))\n        off += 8\n        priceExp := int8(buf[off])\n        off++\n        sizeExp := int8(buf[off])\n        off++\n\n        // group header\n        if off+4 > len(buf) {\n                return nil, fmt.Errorf("too short for group header")\n        }\n        grpBlockLen := binary.LittleEndian.Uint16(buf[off : off+2])\n        numInGroup := binary.LittleEndian.Uint16(buf[off+2 : off+4])\n        off += 4\n\n        items := make([]TradeItem, 0, int(numInGroup))\n        for i := 0; i < int(numInGroup); i++ {\n                entryStart := off\n\n                needMin := 8 + 8 + 8 + 8 + 1 + 1 + 1 + 8\n                if off+needMin > len(buf) {\n                        return nil, fmt.Errorf("too short for trade entry %d", i)\n                }\n\n                fillTime := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n                priceM := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n                sizeM := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n                seq := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n\n                side := uint8(buf[off]); off++\n                isBlock := uint8(buf[off]); off++\n                isRpi := uint8(buf[off]); off++\n\n                fixedConsumed := off - entryStart\n                if fixedConsumed < int(grpBlockLen) {\n                        off += int(grpBlockLen) - fixedConsumed\n                } else if fixedConsumed > int(grpBlockLen) {\n                        return nil, fmt.Errorf("group blockLength too small: %d < %d", grpBlockLen, fixedConsumed)\n                }\n\n                 execID, off2, err := readVarString8(buf, off)\n                if err != nil {\n                        return nil, err\n                }\n                off = off2\n\n\n                items = append(items, TradeItem{\n                        FillTime:     fillTime,\n                        PriceMant:    priceM,\n                        SizeMant:     sizeM,\n                        Price:        applyExp(priceM, priceExp),\n                        Size:         applyExp(sizeM, sizeExp),\n                        Seq:          seq,\n                        Side:         side,\n                        IsBlockTrade: isBlock != 0,\n                        IsRPI:        isRpi != 0,\n                        ExecID:       execID,\n                })\n        }\n\n        symbol, off2, err := readVarString8(buf, off)\n        if err != nil {\n                return nil, err\n        }\n        off = off2\n\n        evt := &PublicTradeEvent{\n                Ts:            ts,\n                PriceExponent: priceExp,\n                SizeExponent:  sizeExp,\n                TradeItems:    items,\n                Symbol:        symbol,\n                ParsedLength:  off,\n        }\n        evt.Header.BlockLength = blk\n        evt.Header.TemplateID = tid\n        evt.Header.SchemaID = sid\n        evt.Header.Version = ver\n        return evt, nil\n}\n\nfunc main() {\n        d := websocket.Dialer{HandshakeTimeout: 10 * time.Second}\n        c, _, err := d.Dial(WSURL, nil)\n        if err != nil {\n                log.Fatal(err)\n        }\n        defer c.Close()\n\n        sub, _ := json.Marshal(map[string]any{"op": "subscribe", "args": []string{Topic}})\n        if err := c.WriteMessage(websocket.TextMessage, sub); err != nil {\n                log.Fatal(err)\n        }\n        log.Println("subscribed:", Topic)\n\n        for {\n                mt, msg, err := c.ReadMessage()\n                if err != nil {\n                        log.Fatal(err)\n                }\n                if mt == websocket.BinaryMessage {\n                        evt, err := parsePublicTradeEvent(msg)\n                        if err != nil {\n                                log.Println("decode error:", err)\n                                continue\n                        }\n                        if len(evt.TradeItems) > 0 {\n                                t0 := evt.TradeItems[0]\n                                log.Printf("%s trades=%d first=%.8f@%.8f seq=%d",\n                                        evt.Symbol, len(evt.TradeItems), t0.Price, t0.Size, t0.Seq)\n                        }\n                } else {\n                        log.Println("TEXT:", string(msg))\n                }\n        }\n}\n')))}u.isMDXComponent=!0}}]);