"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[4754],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),c=r,k=u["".concat(o,".").concat(c)]||u[c]||m[c]||i;return n?a.createElement(k,l(l({ref:t},d),{},{components:n})):a.createElement(k,l({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},43779:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={title:"SBE Level 50 Integration",sidebar_label:"SBE Level 50 Integration",sidebar_position:1},l=void 0,s={unversionedId:"v5/sbe/level-50/sbe-level-50",id:"v5/sbe/level-50/sbe-level-50",title:"SBE Level 50 Integration",description:"Overview",source:"@site/docs/v5/sbe/level-50/sbe-level-50.mdx",sourceDirName:"v5/sbe/level-50",slug:"/v5/sbe/level-50/sbe-level-50",permalink:"/docs/v5/sbe/level-50/sbe-level-50",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"SBE Level 50 Integration",sidebar_label:"SBE Level 50 Integration",sidebar_position:1},sidebar:"v5SideBar",previous:{title:"SBE BBO Integration",permalink:"/docs/v5/sbe/bbo/sbe-bbo"},next:{title:"Fast Order Integration",permalink:"/docs/v5/sbe/fast-order/sbe-fast-order"}},o={},p=[{value:"Overview",id:"overview",level:2},{value:"Order Book Update Logic (Snapshot + Delta Mode)",id:"order-book-update-logic-snapshot--delta-mode",level:2},{value:"Message Types",id:"message-types",level:3},{value:"Rules for the u (Update ID) Field",id:"rules-for-the-u-update-id-field",level:3},{value:"Behavior of <code>u</code>",id:"behavior-of-u",level:4},{value:"Continuity Validation",id:"continuity-validation",level:4},{value:"Rules for Order Book Maintenance",id:"rules-for-order-book-maintenance",level:3},{value:"First Message of connection and reconnection",id:"first-message-of-connection-and-reconnection",level:4},{value:"Snapshot Handling",id:"snapshot-handling",level:4},{value:"Delta Handling",id:"delta-handling",level:4},{value:"Example Push Update",id:"example-push-update",level:3},{value:"Key Differences between SBE &amp; JSON",id:"key-differences-between-sbe--json",level:2},{value:"1. Time Precision",id:"1-time-precision",level:3},{value:"2. Payload Size &amp; Efficiency",id:"2-payload-size--efficiency",level:3},{value:"3. Snapshot Mode Behavior",id:"3-snapshot-mode-behavior",level:3},{value:"4. RPI (Retail Price Improvement) Exclusion",id:"4-rpi-retail-price-improvement-exclusion",level:3},{value:"Level 50 Snapshot partially vs Level 40 full snapshot",id:"level-50-snapshot-partially-vs-level-40-full-snapshot",level:2},{value:"FAQ about field <code>seq</code>",id:"faq-about-field-seq",level:2},{value:"Connection",id:"connection",level:2},{value:"Data Frame Type",id:"data-frame-type",level:3},{value:"Control Messages",id:"control-messages",level:3},{value:"Flow",id:"flow",level:2},{value:"Ping / Pong (JSON control frames)",id:"ping--pong-json-control-frames",level:3},{value:"Subscribe",id:"subscribe",level:3},{value:"SBE XML Template (L50 OB)",id:"sbe-xml-template-l50-ob",level:2},{value:"SBE Level 50 \u2013 Field Reference",id:"sbe-level-50--field-reference",level:2},{value:"Enum: <code>pkgTypeEnum</code> (for <code>pkgType</code>)",id:"enum-pkgtypeenum-for-pkgtype",level:3},{value:"Repeating group element layout (bids)",id:"repeating-group-element-layout-bids",level:2},{value:"Asks Group",id:"asks-group",level:3},{value:"Bids Group",id:"bids-group",level:3},{value:"Supporting composites",id:"supporting-composites",level:2},{value:"<code>varString8</code> (variable string)",id:"varstring8-variable-string",level:3},{value:"SBE Connection Limit",id:"sbe-connection-limit",level:2},{value:"Integration Script",id:"integration-script",level:2},{value:"Python",id:"python",level:3},{value:"Golang",id:"golang",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Channel:")," private MMWS only (not available on public WS)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Topic:")," ",(0,r.kt)("inlineCode",{parentName:"li"},"ob.50.sbe.{symbol}")," (snapshot or delta, every 20 ms)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Format:")," SBE binary frames (",(0,r.kt)("inlineCode",{parentName:"li"},"opcode = 2"),"), little-endian."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Depth:")," 50 levels per side (no RPI in this stream)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Units:")," timestamps in microseconds (\xb5s); price/size are mantissas with exponents.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"order-book-update-logic-snapshot--delta-mode"},"Order Book Update Logic (Snapshot + Delta Mode)"),(0,r.kt)("h3",{id:"message-types"},"Message Types"),(0,r.kt)("p",null,"Order book update streams contain two message types:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"snapshot"),(0,r.kt)("td",{parentName:"tr",align:null},"A full 50-level orderbook image. Must ",(0,r.kt)("strong",{parentName:"td"},"reset")," the local book.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"Incremental updates. Must ",(0,r.kt)("strong",{parentName:"td"},"apply changes")," to the existing book.")))),(0,r.kt)("h3",{id:"rules-for-the-u-update-id-field"},"Rules for the u (Update ID) Field"),(0,r.kt)("h4",{id:"behavior-of-u"},"Behavior of ",(0,r.kt)("inlineCode",{parentName:"h4"},"u")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Field ",(0,r.kt)("inlineCode",{parentName:"li"},"u")," ",(0,r.kt)("strong",{parentName:"li"},"increases monotonically")," for all snapshots and deltas."),(0,r.kt)("li",{parentName:"ul"},"Field ",(0,r.kt)("inlineCode",{parentName:"li"},"u")," ",(0,r.kt)("strong",{parentName:"li"},"does not reset"),", unless there is a system reset or precision change."),(0,r.kt)("li",{parentName:"ul"},"Field ",(0,r.kt)("inlineCode",{parentName:"li"},"u = 1")," always indicates a ",(0,r.kt)("strong",{parentName:"li"},"snapshot"),", and continuity checks must stop.")),(0,r.kt)("h4",{id:"continuity-validation"},"Continuity Validation"),(0,r.kt)("p",null,"Continuity must be checked ",(0,r.kt)("strong",{parentName:"p"},"only when ",(0,r.kt)("inlineCode",{parentName:"strong"},"u != 1")),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Condition"),(0,r.kt)("th",{parentName:"tr",align:null},"Action"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u != 1")),(0,r.kt)("td",{parentName:"tr",align:null},"Validate continuity: next ",(0,r.kt)("inlineCode",{parentName:"td"},"u")," should follow previous ",(0,r.kt)("inlineCode",{parentName:"td"},"u + 1"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u == 1")),(0,r.kt)("td",{parentName:"tr",align:null},"Special snapshot (service restart / precision change). ",(0,r.kt)("strong",{parentName:"td"},"Do not")," perform continuity checks.")))),(0,r.kt)("h3",{id:"rules-for-order-book-maintenance"},"Rules for Order Book Maintenance"),(0,r.kt)("h4",{id:"first-message-of-connection-and-reconnection"},"First Message of connection and reconnection"),(0,r.kt)("p",null,"After subscribing, the ",(0,r.kt)("strong",{parentName:"p"},"first message is always a snapshot"),".",(0,r.kt)("br",{parentName:"p"}),"\n","Clients must initialize the local book with it."),(0,r.kt)("h4",{id:"snapshot-handling"},"Snapshot Handling"),(0,r.kt)("p",null,"A snapshot must always ",(0,r.kt)("strong",{parentName:"p"},"replace the entire local order book"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Clear local bids and asks."),(0,r.kt)("li",{parentName:"ul"},"Rebuild from snapshot data."),(0,r.kt)("li",{parentName:"ul"},"Set local ",(0,r.kt)("inlineCode",{parentName:"li"},"lastU = snapshot.u"),".")),(0,r.kt)("p",null,"Snapshots may appear:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"after initial subscription"),(0,r.kt)("li",{parentName:"ul"},"when the number of changed levels > 100 (extreme market condition auto-fallback)"),(0,r.kt)("li",{parentName:"ul"},"after internal service restart"),(0,r.kt)("li",{parentName:"ul"},"after exponent / precision changes")),(0,r.kt)("h4",{id:"delta-handling"},"Delta Handling"),(0,r.kt)("p",null,"A delta applies ",(0,r.kt)("strong",{parentName:"p"},"incrementally"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Insert/update levels with ",(0,r.kt)("inlineCode",{parentName:"li"},"size > 0"),"."),(0,r.kt)("li",{parentName:"ul"},"Remove levels when ",(0,r.kt)("inlineCode",{parentName:"li"},"size == 0"),"."),(0,r.kt)("li",{parentName:"ul"},"Continue continuity checks using the ",(0,r.kt)("inlineCode",{parentName:"li"},"u")," field.")),(0,r.kt)("h3",{id:"example-push-update"},"Example Push Update"),(0,r.kt)("p",null,"Below is a real case where the connection stays healthy and messages arrive in order:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"u"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10000"),(0,r.kt)("td",{parentName:"tr",align:null},"snapshot"),(0,r.kt)("td",{parentName:"tr",align:null},"First message after subscription.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10001"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"Incremental updates. Must ",(0,r.kt)("strong",{parentName:"td"},"apply changes")," to the existing book.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10002"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"Normal incremental update.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10003"),(0,r.kt)("td",{parentName:"tr",align:null},"snapshot"),(0,r.kt)("td",{parentName:"tr",align:null},"Large market move (> 100 level changes). Use snapshot to ",(0,r.kt)("strong",{parentName:"td"},"replace")," local book.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10004"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"Continue delta from the new snapshot.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"snapshot"),(0,r.kt)("td",{parentName:"tr",align:null},"Service restarted / precision changed \u2014 reset ",(0,r.kt)("inlineCode",{parentName:"td"},"u")," to 1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"New continuity sequence.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"key-differences-between-sbe--json"},"Key Differences between SBE & JSON"),(0,r.kt)("h3",{id:"1-time-precision"},"1. Time Precision"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"JSON:")," timestamps typically in ",(0,r.kt)("strong",{parentName:"li"},"milliseconds (ms)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"SBE:")," all timestamps (",(0,r.kt)("inlineCode",{parentName:"li"},"ts"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"cts"),") are in ",(0,r.kt)("strong",{parentName:"li"},"microseconds (\xb5s)")," for higher precision and better sequencing accuracy.")),(0,r.kt)("h3",{id:"2-payload-size--efficiency"},"2. Payload Size & Efficiency"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"SBE:")," binary-packed and fixed-width where possible \u2192 ",(0,r.kt)("strong",{parentName:"li"},"very compact"),".  ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"A typical 50\xd72 depth update is around ",(0,r.kt)("strong",{parentName:"li"},"1.7 KB")," per frame."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"JSON:")," verbose text format \u2192 larger payload.  ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Equivalent depth update is about ",(0,r.kt)("strong",{parentName:"li"},"2.4 KB"),", and can spike to ",(0,r.kt)("strong",{parentName:"li"},"4.6 KB")," during volatile markets.")))),(0,r.kt)("h3",{id:"3-snapshot-mode-behavior"},"3. Snapshot Mode Behavior"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SBE mirrors JSON v5 behavior:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"50-depth snapshots serve as ",(0,r.kt)("strong",{parentName:"li"},"baseline reference")," for delta synchronization.")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Extreme Market Condition Handling")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When a delta contains ",(0,r.kt)("strong",{parentName:"li"},"more than 100 combined bid+ask updates")," (buy + sell), the system automatically sends a ",(0,r.kt)("strong",{parentName:"li"},"full snapshot")," instead of a delta."),(0,r.kt)("li",{parentName:"ul"},"Ensures client books resync cleanly."),(0,r.kt)("li",{parentName:"ul"},"Prevents explosion of delta packets during high churn."),(0,r.kt)("li",{parentName:"ul"},"Keeps snapshot size fixed length for predictable decoding.")),(0,r.kt)("h3",{id:"4-rpi-retail-price-improvement-exclusion"},"4. RPI (Retail Price Improvement) Exclusion"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SBE 50-level feed ",(0,r.kt)("strong",{parentName:"li"},"does not include RPI fields"),", only regular best bid/ask levels.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"level-50-snapshot-partially-vs-level-40-full-snapshot"},"Level 50 Snapshot partially vs Level 40 full snapshot"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pros")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Delta + small partial snapshot keeps consuming less bandwidth."),(0,r.kt)("li",{parentName:"ul"},"Extreme Market Handling: partial snapshot + delta is more robust."),(0,r.kt)("li",{parentName:"ul"},"Supports ",(0,r.kt)("strong",{parentName:"li"},"more than 10 levels"),"."),(0,r.kt)("li",{parentName:"ul"},"Delta + partial snapshot provides continuous sync (similar to CME, Nasdaq, Binance, OKX).")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cons")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Client must handle ",(0,r.kt)("strong",{parentName:"li"},"partial snapshot + deltas")," to construct orderbook."),(0,r.kt)("li",{parentName:"ul"},"Needs correct ",(0,r.kt)("strong",{parentName:"li"},"delta sequence alignment"),".")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"faq-about-field-seq"},"FAQ about field ",(0,r.kt)("inlineCode",{parentName:"h2"},"seq")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"seq")," field is a ",(0,r.kt)("strong",{parentName:"li"},"unified global sequence number"),".",(0,r.kt)("br",{parentName:"li"}),"It remains consistent across different depths. It is monotonically increasing, but ",(0,r.kt)("strong",{parentName:"li"},"not guaranteed to be continuous"),"."),(0,r.kt)("li",{parentName:"ul"},"All messages are generated in the quote service, where both ",(0,r.kt)("inlineCode",{parentName:"li"},"seq")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"u")," values are assigned."),(0,r.kt)("li",{parentName:"ul"},"In the WebSocket server, messages are forwarded transparently without modification.",(0,r.kt)("br",{parentName:"li"}),"Therefore, for all clients connected to the same WS server, ",(0,r.kt)("strong",{parentName:"li"},"the same message has the same ",(0,r.kt)("inlineCode",{parentName:"strong"},"seq")," and ",(0,r.kt)("inlineCode",{parentName:"strong"},"u")," values"),", regardless of the connection.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"connection"},"Connection"),(0,r.kt)("p",null,"Please use your ",(0,r.kt)("strong",{parentName:"p"},"dedicated MMWS host")," to connect."),(0,r.kt)("h3",{id:"data-frame-type"},"Data Frame Type"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SBE messages are transmitted as ",(0,r.kt)("strong",{parentName:"li"},"binary frames")," (",(0,r.kt)("inlineCode",{parentName:"li"},"opcode = 2"),").")),(0,r.kt)("h3",{id:"control-messages"},"Control Messages"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Subscription, unsubscription, ping/pong, and other control messages follow the ",(0,r.kt)("strong",{parentName:"li"},"Bybit V5 API standard"),".")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"flow"},"Flow"),(0,r.kt)("h3",{id:"ping--pong-json-control-frames"},"Ping / Pong (JSON control frames)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Send Ping")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"req_id": "100001", "op": "ping"}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Receive Pong")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "success": true,\n  "ret_msg": "pong",\n  "conn_id": "xxxxx-xx",\n  "req_id": "",\n  "op": "ping"\n}\n')),(0,r.kt)("h3",{id:"subscribe"},"Subscribe"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Topic format: ",(0,r.kt)("inlineCode",{parentName:"li"},"ob.50.sbe.<symbol>")),(0,r.kt)("li",{parentName:"ul"},"Example: ",(0,r.kt)("inlineCode",{parentName:"li"},"BTCUSDT"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ETHUSDT"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Subscribe request")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"op": "subscribe", "args": ["ob.50.sbe.BTCUSDT"]}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Subscription confirmation")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "success": true,\n  "ret_msg": "",\n  "conn_id": "d30fdpbboasp1pjbe7r0",\n  "req_id": "xxx",\n  "op": "subscribe"\n}\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"sbe-xml-template-l50-ob"},"SBE XML Template (L50 OB)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8"?>\n<sbe:messageSchema xmlns:sbe="http://fixprotocol.io/2016/sbe"\n                   xmlns:mbx="https://bybit-exchange.github.io/docs/v5/intro"\n                   package="quote.sbe"\n                   id="1"\n                   version="0"\n                   semanticVersion="1.0.0"\n                   description="Bybit market data streams SBE message schema"\n                   byteOrder="littleEndian"\n                   headerType="messageHeader">\n  <types>\n    <composite name="messageHeader" description="Template ID and length of message root">\n      <type name="blockLength" primitiveType="uint16"/>\n      <type name="templateId" primitiveType="uint16"/>\n      <type name="schemaId" primitiveType="uint16"/>\n      <type name="version" primitiveType="uint16"/>\n    </composite>\n\n    <composite name="varString8" description="Variable length UTF-8 string.">\n      <type name="length" primitiveType="uint8"/>\n      <type name="varData" length="0" primitiveType="uint8" semanticType="String" characterEncoding="UTF-8"/>\n    </composite>\n\n    <composite name="groupSize16Encoding" description="Repeating group dimensions.">\n      <type name="blockLength" primitiveType="uint16"/>\n      <type name="numInGroup" primitiveType="uint16"/>\n    </composite>\n\n    \x3c!-- NEW: package type enum --\x3e\n    <enum name="pkgTypeEnum" encodingType="uint8">\n      <validValue name="SNAPSHOT">0</validValue>\n      <validValue name="DELTA">1</validValue>\n    </enum>\n  </types>\n\n  \x3c!-- Stream event for "ob.rpi.1.sbe.<symbol>" channel --\x3e\n  <sbe:message name="BestOBRpiEvent" id="20000">\n    <field id="1"  name="ts"             type="int64" description="The timestamp in microseconds that the system generates the data"/>\n    <field id="2"  name="seq"            type="int64" description="Cross sequence ID"/>\n    <field id="3"  name="cts"            type="int64" description="The timestamp in microseconds from the matching engine when this orderbook data is produced."/>\n    <field id="4"  name="u"              type="int64" description="Update Id"/>\n    <field id="5"  name="askNormalPrice" type="int64" mbx:exponent="priceExponent" description="Mantissa for the best ask normal price"/>\n    <field id="6"  name="askNormalSize"  type="int64" mbx:exponent="sizeExponent" description="Mantissa for the best ask normal size"/>\n    <field id="7"  name="askRpiPrice"    type="int64" mbx:exponent="priceExponent" description="Mantissa for the best ask rpi price"/>\n    <field id="8"  name="askRpiSize"     type="int64" mbx:exponent="sizeExponent" description="Mantissa for the best ask rpi size"/>\n    <field id="9"  name="bidNormalPrice" type="int64" mbx:exponent="priceExponent" description="Mantissa for the best bid normal price"/>\n    <field id="10" name="bidNormalSize"  type="int64" mbx:exponent="sizeExponent" description="Mantissa for the best bid normal size"/>\n    <field id="11" name="bidRpiPrice"    type="int64" mbx:exponent="priceExponent" description="Mantissa for the best bid rpi price"/>\n    <field id="12" name="bidRpiSize"     type="int64" mbx:exponent="sizeExponent" description="Mantissa for the best bid rpi size"/>\n    <field id="13" name="priceExponent"  type="int8"  description="Price exponent for decimal point positioning"/>\n    <field id="14" name="sizeExponent"   type="int8"  description="Size exponent for decimal point positioning"/>\n    <data  id="55" name="symbol"         type="varString8"/>\n  </sbe:message>\n\n  \x3c!-- Stream event for "ob.50.sbe.<symbol>" channel --\x3e\n  <sbe:message name="OBL50Event" id="20001">\n    <field id="1"  name="ts"            type="int64" description="The timestamp in microseconds that the system generates the data"/>\n    <field id="2"  name="seq"           type="int64" description="Cross sequence ID"/>\n    <field id="3"  name="cts"           type="int64" description="The timestamp in microseconds from the matching engine when this orderbook data is produced."/>\n    <field id="4"  name="u"             type="int64" description="Update Id"/>\n    <field id="5"  name="priceExponent" type="int8"  description="Price exponent for decimal point positioning"/>\n    <field id="6"  name="sizeExponent"  type="int8"  description="Size exponent for decimal point positioning"/>\n    \x3c!-- NEW: package type --\x3e\n    <field id="7"  name="pkgType"       type="pkgTypeEnum" description="Package type: 0 = SNAPSHOT (full book), 1 = DELTA (partial update)"/>\n\n    <group id="40" name="asks" dimensionType="groupSize16Encoding" description="Sell side order book updates">\n      <field id="1" name="price" type="int64" description="Price mantissa"/>\n      <field id="2" name="size"  type="int64" description="Size mantissa"/>\n    </group>\n\n    <group id="41" name="bids" dimensionType="groupSize16Encoding" description="Buy side order book updates">\n      <field id="1" name="price" type="int64" description="Price mantissa"/>\n      <field id="2" name="size"  type="int64" description="Size mantissa"/>\n    </group>\n\n    <data id="55" name="symbol" type="varString8"/>\n  </sbe:message>\n</sbe:messageSchema>\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"sbe-level-50--field-reference"},"SBE Level 50 \u2013 Field Reference"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Message:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"OBL50Event")," (id = 20001)"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field Name"),(0,r.kt)("th",{parentName:"tr",align:null},"ID"),(0,r.kt)("th",{parentName:"tr",align:null},"SBE Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Unit / Format"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ts"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"\xb5s"),(0,r.kt)("td",{parentName:"tr",align:null},"System generation time at push side (dispatcher).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"seq"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Cross-sequence id (monotonic per feed; not guaranteed continuous).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cts"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"\xb5s"),(0,r.kt)("td",{parentName:"tr",align:null},"Matching-engine creation time of this OB snapshot or delta; used for latency measurements.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"u"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Update id (monotonic per symbol). Useful to check continuity.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"priceExponent"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"int8"),(0,r.kt)("td",{parentName:"tr",align:null},"exponent"),(0,r.kt)("td",{parentName:"tr",align:null},"Decimal places for price. Display price = mantissa \xd7 10^",(0,r.kt)("inlineCode",{parentName:"td"},"priceExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sizeExponent"),(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"int8"),(0,r.kt)("td",{parentName:"tr",align:null},"exponent"),(0,r.kt)("td",{parentName:"tr",align:null},"Decimal places for size. Display size = mantissa \xd7 10^",(0,r.kt)("inlineCode",{parentName:"td"},"sizeExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pkgType"),(0,r.kt)("td",{parentName:"tr",align:null},"7"),(0,r.kt)("td",{parentName:"tr",align:null},"uint8 (",(0,r.kt)("inlineCode",{parentName:"td"},"pkgTypeEnum"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Package type (0 = snapshot, 1 = delta).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"asks"),(0,r.kt)("td",{parentName:"tr",align:null},"40"),(0,r.kt)("td",{parentName:"tr",align:null},"group(",(0,r.kt)("inlineCode",{parentName:"td"},"groupSize16Encoding"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014"),(0,r.kt)("td",{parentName:"tr",align:null},"Sell side updates (up to 50 levels).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bids"),(0,r.kt)("td",{parentName:"tr",align:null},"41"),(0,r.kt)("td",{parentName:"tr",align:null},"group(",(0,r.kt)("inlineCode",{parentName:"td"},"groupSize16Encoding"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014"),(0,r.kt)("td",{parentName:"tr",align:null},"Buy side updates (up to 50 levels).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"symbol"),(0,r.kt)("td",{parentName:"tr",align:null},"55"),(0,r.kt)("td",{parentName:"tr",align:null},"varString8"),(0,r.kt)("td",{parentName:"tr",align:null},"UTF-8"),(0,r.kt)("td",{parentName:"tr",align:null},"1-byte length + bytes, e.g., ",(0,r.kt)("inlineCode",{parentName:"td"},'0x07 "BTCUSDT"'),".")))),(0,r.kt)("h3",{id:"enum-pkgtypeenum-for-pkgtype"},"Enum: ",(0,r.kt)("inlineCode",{parentName:"h3"},"pkgTypeEnum")," (for ",(0,r.kt)("inlineCode",{parentName:"h3"},"pkgType"),")"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SNAPSHOT"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"Full Level-50 snapshot of the order book. Local book should be fully replaced.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DELTA"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Incremental update on top of the last applied book. Only listed levels need updates/removal.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"repeating-group-element-layout-bids"},"Repeating group element layout (bids)"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parent Group"),(0,r.kt)("th",{parentName:"tr",align:null},"Element Field"),(0,r.kt)("th",{parentName:"tr",align:null},"SBE Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Unit / Format"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"asks / bids"),(0,r.kt)("td",{parentName:"tr",align:null},"price"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"mantissa"),(0,r.kt)("td",{parentName:"tr",align:null},"Apply ",(0,r.kt)("inlineCode",{parentName:"td"},"priceExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"asks / bids"),(0,r.kt)("td",{parentName:"tr",align:null},"size"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"mantissa"),(0,r.kt)("td",{parentName:"tr",align:null},"Apply ",(0,r.kt)("inlineCode",{parentName:"td"},"sizeExponent"),".")))),(0,r.kt)("h3",{id:"asks-group"},"Asks Group"),(0,r.kt)("p",null,"Sell side orderbook updates."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field (id)"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"price (1)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Ask price mantissa. Display ask price = ",(0,r.kt)("inlineCode",{parentName:"td"},"price \xd7 10^priceExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"size  (2)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Ask size mantissa. Display ask size  = ",(0,r.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")))),(0,r.kt)("h3",{id:"bids-group"},"Bids Group"),(0,r.kt)("p",null,"Buy side orderbook updates."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field (id)"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"price (1)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Bid price mantissa. Display bid price = ",(0,r.kt)("inlineCode",{parentName:"td"},"price \xd7 10^priceExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"size  (2)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Bid size mantissa. Display bid size  = ",(0,r.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")))),(0,r.kt)("p",null,"Order: groups are encoded as: ",(0,r.kt)("inlineCode",{parentName:"p"},"blockLength:uint16"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"numInGroup:uint16"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"numInGroup")," elements, each exactly ",(0,r.kt)("inlineCode",{parentName:"p"},"blockLength")," bytes.",(0,r.kt)("br",{parentName:"p"}),"\n","In this schema each element is ",(0,r.kt)("strong",{parentName:"p"},"16 bytes")," (two ",(0,r.kt)("inlineCode",{parentName:"p"},"int64"),"s)."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"supporting-composites"},"Supporting composites"),(0,r.kt)("h3",{id:"varstring8-variable-string"},(0,r.kt)("inlineCode",{parentName:"h3"},"varString8")," (variable string)"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"SBE Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"length"),(0,r.kt)("td",{parentName:"tr",align:null},"uint8"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of bytes that follow.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"varData"),(0,r.kt)("td",{parentName:"tr",align:null},"uint8","[length]"),(0,r.kt)("td",{parentName:"tr",align:null},"UTF-8 bytes.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"sbe-connection-limit"},"SBE Connection Limit"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Spot:")," 1500 connections limit per dedicated MMWS host."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Futures (linear + inverse):")," 3000 connections limit per dedicated MMWS host."),(0,r.kt)("li",{parentName:"ul"},"Once you breach the connection limit, new connections return ",(0,r.kt)("strong",{parentName:"li"},"HTTP 429"),".")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"integration-script"},"Integration Script"),(0,r.kt)("h3",{id:"python"},"Python"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import json\nimport logging\nimport struct\nimport threading\nimport time\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Tuple\n\nimport websocket\n\nlogging.basicConfig(\n    filename=\'logfile_ob50.log\',\n    level=logging.INFO,\n    format=\'%(asctime)s %(levelname)s %(message)s\'\n)\n\n# -------------------------------------------------------------------\n# Config\n# -------------------------------------------------------------------\n\n# L50 SBE order book topic\nTOPIC = "ob.50.sbe.BTCUSDT"\n\n# Adjust URL for spot / contract environment as needed:\nWS_URL = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\n\n# -------------------------------------------------------------------\n# SBE Parser for OBL50Event (template_id = 20001)\n#\n# XML schema:\n#   ts(int64), seq(int64), cts(int64), u(int64),\n#   priceExponent(int8), sizeExponent(int8),\n#   pkgType(uint8)   # 0 = SNAPSHOT, 1 = DELTA\n#   group asks: blockLen(uint16), numInGroup(uint16),\n#               then numInGroup * [ price(int64), size(int64) ]\n#   group bids: same as asks\n#   symbol(varString8)\n# -------------------------------------------------------------------\n\nclass SBEOBL50Parser:\n    def __init__(self):\n        # message header: blockLength, templateId, schemaId, version\n        self.header_fmt = "<HHHH"\n        self.header_sz = struct.calcsize(self.header_fmt)\n\n        # fixed body fields:\n        # ts, seq, cts, u   -> 4 x int64\n        # priceExponent, sizeExponent -> 2 x int8\n        # pkgType -> uint8\n        self.body_fmt = "<qqqqbbB"   # 4*q + 2*b + B\n        self.body_sz = struct.calcsize(self.body_fmt)\n\n        # group header for repeating groups: blockLength(uint16), numInGroup(uint16)\n        self.group_hdr_fmt = "<HH"\n        self.group_hdr_sz = struct.calcsize(self.group_hdr_fmt)\n\n        # each group entry: price(int64), size(int64)\n        self.level_fmt = "<qq"\n        self.level_sz = struct.calcsize(self.level_fmt)\n\n        self.target_template_id = 20001\n\n    # ---------------- core small helpers ----------------\n\n    def _parse_header(self, data: bytes) -> Dict[str, Any]:\n        if len(data) < self.header_sz:\n            raise ValueError("insufficient data for SBE header")\n        block_length, template_id, schema_id, version = struct.unpack_from(\n            self.header_fmt, data, 0\n        )\n        return {\n            "block_length": block_length,\n            "template_id": template_id,\n            "schema_id": schema_id,\n            "version": version,\n        }\n\n    @staticmethod\n    def _parse_varstring8(data: bytes, offset: int) -> Tuple[str, int]:\n        if offset + 1 > len(data):\n            raise ValueError("insufficient data for varString8 length")\n        (length,) = struct.unpack_from("<B", data, offset)\n        offset += 1\n        if length == 0:\n            return "", offset\n        if offset + length > len(data):\n            raise ValueError("insufficient data for varString8 bytes")\n        s = data[offset: offset + length].decode("utf-8")\n        offset += length\n        return s, offset\n\n    @staticmethod\n    def _apply_exponent(value: int, exponent: int) -> float:\n        return value / (10 ** exponent) if exponent >= 0 else value * (10 ** (-exponent))\n\n    def _parse_levels(self, data: bytes, offset: int) -> Tuple[List[Dict[str, float]], int]:\n        """\n        Parse one repeating group (asks or bids).\n        Layout:\n           uint16 blockLength\n           uint16 numInGroup\n           numInGroup * [ price(int64), size(int64) ] (within blockLength)\n        """\n        if offset + self.group_hdr_sz > len(data):\n            raise ValueError("insufficient data for group header")\n        block_len, num_in_group = struct.unpack_from(self.group_hdr_fmt, data, offset)\n        offset += self.group_hdr_sz\n\n        if block_len < self.level_sz:\n            raise ValueError(f"blockLength({block_len}) < level_sz({self.level_sz})")\n\n        levels = []\n        for _ in range(num_in_group):\n            if offset + block_len > len(data):\n                raise ValueError("insufficient data for group entry")\n            # we only care about first 16 bytes (price, size)\n            price_m, size_m = struct.unpack_from(self.level_fmt, data, offset)\n            offset += block_len  # skip the whole block (safe if future adds extra fields)\n\n            levels.append({\n                "price_m": price_m,\n                "size_m": size_m,\n            })\n        return levels, offset\n\n    # ---------------- public parse ----------------\n\n    def parse(self, data: bytes) -> Dict[str, Any]:\n        hdr = self._parse_header(data)\n        if hdr["template_id"] != self.target_template_id:\n            raise NotImplementedError(f"unsupported template_id={hdr[\'template_id\']}")\n\n        if len(data) < self.header_sz + self.body_sz:\n            raise ValueError("insufficient data for OBL50Event body")\n\n        # parse fixed body\n        (ts, seq, cts, u,\n         price_exp, size_exp, pkg_type) = struct.unpack_from(\n            self.body_fmt, data, self.header_sz\n        )\n\n        offset = self.header_sz + self.body_sz\n\n        # asks group\n        asks_raw, offset = self._parse_levels(data, offset)\n        # bids group\n        bids_raw, offset = self._parse_levels(data, offset)\n        # symbol\n        symbol, offset = self._parse_varstring8(data, offset)\n\n        # apply exponents\n        asks = [\n            {\n                "price": self._apply_exponent(l["price_m"], price_exp),\n                "size": self._apply_exponent(l["size_m"], size_exp),\n            }\n            for l in asks_raw\n        ]\n        bids = [\n            {\n                "price": self._apply_exponent(l["price_m"], price_exp),\n                "size": self._apply_exponent(l["size_m"], size_exp),\n            }\n            for l in bids_raw\n        ]\n\n        return {\n            "header": hdr,\n            "ts": ts,\n            "seq": seq,\n            "cts": cts,\n            "u": u,\n            "price_exponent": price_exp,\n            "size_exponent": size_exp,\n            "pkg_type": pkg_type,   # 0 = SNAPSHOT, 1 = DELTA\n            "symbol": symbol,\n            "asks": asks,\n            "bids": bids,\n            "parsed_length": offset,\n        }\n\n\nparser = SBEOBL50Parser()\n\n# -------------------------------------------------------------------\n# WebSocket handlers\n# -------------------------------------------------------------------\n\ndef on_message(ws, message):\n    try:\n        if isinstance(message, (bytes, bytearray)):\n            decoded = parser.parse(message)\n\n            pkg_type = decoded["pkg_type"]\n            pkg_str = "SNAPSHOT" if pkg_type == 0 else "DELTA" if pkg_type == 1 else f"UNKNOWN({pkg_type})"\n\n            asks = decoded["asks"]\n            bids = decoded["bids"]\n\n            best_ask = asks[0] if asks else {"price": 0.0, "size": 0.0}\n            best_bid = bids[0] if bids else {"price": 0.0, "size": 0.0}\n\n            logging.info(\n                "SBE %s u=%s seq=%s type=%s asks=%d bids=%d "\n                "BEST bid=%.8f@%.8f ask=%.8f@%.8f ts=%s",\n                decoded["symbol"], decoded["u"], decoded["seq"], pkg_str,\n                len(asks), len(bids),\n                best_bid["price"], best_bid["size"],\n                best_ask["price"], best_ask["size"],\n                decoded["ts"],\n            )\n\n            print(\n                f"{decoded[\'symbol\']}  u={decoded[\'u\']}  seq={decoded[\'seq\']}  {pkg_str}  "\n                f"levels: asks={len(asks)} bids={len(bids)}  "\n                f"BEST: bid {best_bid[\'price\']:.8f} x {best_bid[\'size\']:.8f}  |  "\n                f"ask {best_ask[\'price\']:.8f} x {best_ask[\'size\']:.8f}"\n            )\n\n        else:\n            # text frame: control / errors / ping-pong\n            try:\n                obj = json.loads(message)\n                logging.info("TEXT %s", obj)\n                print("TEXT:", obj)\n            except json.JSONDecodeError:\n                logging.warning("non-JSON text frame: %r", message)\n                print("TEXT(non-json):", message)\n    except Exception as e:\n        logging.exception("decode error: %s", e)\n        print("decode error:", e)\n\n\ndef on_error(ws, error):\n    print("WS error:", error)\n    logging.error("WS error: %s", error)\n\n\ndef on_close(ws, *_):\n    print("### connection closed ###")\n    logging.info("connection closed")\n\n\ndef ping_per(ws):\n    while True:\n        try:\n            ws.send(json.dumps({"op": "ping"}))\n        except Exception:\n            return\n        time.sleep(10)\n\n\ndef on_open(ws):\n    print("opened")\n    sub = {"op": "subscribe", "args": [TOPIC]}\n    ws.send(json.dumps(sub))\n    print("subscribed:", TOPIC)\n\n    # background ping thread\n    threading.Thread(target=ping_per, args=(ws,), daemon=True).start()\n\n\ndef on_pong(ws, *_):\n    print("pong received")\n\n\ndef on_ping(ws, *_):\n    print("ping received @", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))\n\n\ndef connWS():\n    ws = websocket.WebSocketApp(\n        WS_URL,\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n        on_ping=on_ping,\n        on_pong=on_pong,\n    )\n    ws.run_forever(ping_interval=20, ping_timeout=10)\n\n\nif __name__ == "__main__":\n    websocket.enableTrace(False)\n    connWS()\n    \n')),(0,r.kt)("h3",{id:"golang"},"Golang"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// sbe_ob50_client.go\npackage main\n\nimport (\n    "bytes"\n    "compress/flate"\n    "encoding/binary"\n    "encoding/json"\n    "fmt"\n    "log"\n    "math"\n    "time"\n\n    "github.com/gorilla/websocket"\n    "yourmodule/quote" // generated SBE package\n)\n\nconst (\n    WSURL   = "wss://stream.bybit.com/v5/market/sbe"\n    CHANNEL = "ob.50.sbe.BTCUSDT"\n)\n\nfunc toReal(mantissa int64, exponent int8) float64 {\n    return float64(mantissa) * math.Pow10(int(exponent))\n}\n\nfunc decodeOBL50(buf []byte) (*quote.OBL50Event, error) {\n    var hdr quote.MessageHeader\n    reader := bytes.NewReader(buf)\n\n    // decode messageHeader (little endian)\n    if err := binary.Read(reader, binary.LittleEndian, &hdr); err != nil {\n        return nil, fmt.Errorf("read header: %w", err)\n    }\n\n    if hdr.TemplateId != 20001 {\n        return nil, fmt.Errorf("unexpected templateId: %d", hdr.TemplateId)\n    }\n\n    var msg quote.OBL50Event\n    // many generators provide WrapForDecode; here assume we can read the fixed block then groups\n    if err := msg.Decode(reader, int(hdr.BlockLength), int(hdr.Version)); err != nil {\n        return nil, fmt.Errorf("decode OBL50: %w", err)\n    }\n\n    return &msg, nil\n}\n\nfunc main() {\n    book := NewOrderBook()\n\n    dialer := websocket.Dialer{\n        HandshakeTimeout: 10 * time.Second,\n        EnableCompression: false,\n    }\n\n    conn, _, err := dialer.Dial(WSURL, nil)\n    if err != nil {\n        log.Fatalf("dial: %v", err)\n    }\n    defer conn.Close()\n\n    // subscribe\n    sub := map[string]interface{}{\n        "op":   "subscribe",\n        "args": []string{CHANNEL},\n    }\n    if err := conn.WriteJSON(sub); err != nil {\n        log.Fatalf("subscribe: %v", err)\n    }\n\n    for {\n        mt, data, err := conn.ReadMessage()\n        if err != nil {\n            log.Fatalf("read: %v", err)\n        }\n\n        if mt == websocket.TextMessage {\n            // control JSON or pong etc\n            var m map[string]interface{}\n            _ = json.Unmarshal(data, &m)\n            continue\n        }\n\n        // if server wraps SBE in per-message deflate, you may need to decompress:\n        if isDeflatedFrame(data) {\n            data, err = inflate(data)\n            if err != nil {\n                log.Printf("inflate error: %v", err)\n                continue\n            }\n        }\n\n        msg, err := decodeOBL50(data)\n        if err != nil {\n            log.Printf("decode error: %v", err)\n            continue\n        }\n\n        u := msg.U\n        pkgType := msg.PkgType // 0 snapshot, 1 delta\n        pxExp := msg.PriceExponent\n        szExp := msg.SizeExponent\n\n        // extract levels\n        var asks, bids [][2]float64\n        for _, a := range msg.Asks {\n            p := toReal(a.Price, pxExp)\n            sz := toReal(a.Size, szExp)\n            asks = append(asks, [2]float64{p, sz})\n        }\n        for _, b := range msg.Bids {\n            p := toReal(b.Price, pxExp)\n            sz := toReal(b.Size, szExp)\n            bids = append(bids, [2]float64{p, sz})\n        }\n\n        // continuity logic:\n        if u == 1 {\n            // service restart / precision change snapshot\n            book.Asks.SnapshotFrom(asks)\n            book.Bids.SnapshotFrom(bids)\n            book.LastU = 1\n            fmt.Printf("[RESET SNAPSHOT] u=%d seq=%d symbol=%s\\n", u, msg.Seq, msg.Symbol)\n            continue\n        }\n\n        if book.LastU != 0 && u != book.LastU+1 {\n            log.Printf("[WARN] u jump: lastU=%d newU=%d \u2013 consider resync", book.LastU, u)\n        }\n\n        if pkgType == quote.PkgTypeEnum_SNAPSHOT {\n            book.Asks.SnapshotFrom(asks)\n            book.Bids.SnapshotFrom(bids)\n        } else {\n            for _, lv := range asks {\n                book.Asks.Apply(lv[0], lv[1])\n            }\n            for _, lv := range bids {\n                book.Bids.Apply(lv[0], lv[1])\n            }\n        }\n\n        book.LastU = u\n        bestBid := book.Bids.BestBid()\n        bestAsk := book.Asks.BestAsk()\n        fmt.Printf("u=%d pkgType=%d bestBid=%.5f bestAsk=%.5f\\n", u, pkgType, bestBid, bestAsk)\n    }\n}\n\n// helpers (optional, depending on ws framing)\nfunc isDeflatedFrame(data []byte) bool {\n    // placeholder: detect by protocol; many setups know from WS sub-protocol\n    return false\n}\n\nfunc inflate(data []byte) ([]byte, error) {\n    r := flate.NewReader(bytes.NewReader(data))\n    defer r.Close()\n\n    var out bytes.Buffer\n    if _, err := out.ReadFrom(r); err != nil {\n        return nil, err\n    }\n    return out.Bytes(), nil\n}\n')))}m.isMDXComponent=!0}}]);