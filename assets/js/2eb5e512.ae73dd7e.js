"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[4204],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>u});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(t),u=i,c=m["".concat(s,".").concat(u)]||m[u]||f[u]||a;return t?r.createElement(c,l(l({ref:n},d),{},{components:t})):r.createElement(c,l({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,l=new Array(a);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<a;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4756:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=t(87462),i=(t(67294),t(3905));const a={title:"SBE Public Trade Integration",sidebar_label:"SBE Public Trade Integration",sidebar_position:3},l=void 0,o={unversionedId:"v5/sbe/sbe-public-trade/sbe-public-trade",id:"v5/sbe/sbe-public-trade/sbe-public-trade",title:"SBE Public Trade Integration",description:"Overview",source:"@site/docs/v5/sbe/sbe-public-trade/sbe-public-trade.mdx",sourceDirName:"v5/sbe/sbe-public-trade",slug:"/v5/sbe/sbe-public-trade/",permalink:"/docs/v5/sbe/sbe-public-trade/",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"SBE Public Trade Integration",sidebar_label:"SBE Public Trade Integration",sidebar_position:3},sidebar:"v5SideBar",previous:{title:"SBE Level 50 Integration",permalink:"/docs/v5/sbe/level-50/sbe-level-50"},next:{title:"Connect",permalink:"/docs/v5/ws/connect"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Flow",id:"flow",level:2},{value:"Ping / Pong (JSON control frames)",id:"ping--pong-json-control-frames",level:3},{value:"Subscribe",id:"subscribe",level:3},{value:"SBE XML Template (Public Trade)",id:"sbe-xml-template-public-trade",level:2},{value:"Field Reference",id:"field-reference",level:2},{value:"Each tradeItemsi entry",id:"each-tradeitemsi-entry",level:3},{value:"SideType",id:"sidetype",level:4},{value:"BoolEnum",id:"boolenum",level:4},{value:"Integration Script",id:"integration-script",level:2},{value:"Python",id:"python",level:3},{value:"Golang",id:"golang",level:3}],d={toc:p};function f(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Channel:")," private MMWS only (not available on public WS)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"WSURL:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"wss://<your-public-stream-host>.bybit-aws.com/v5/public-sbe/<category>"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Topic:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"publicTrade.sbe.<symbol>"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Format:")," SBE binary frames (",(0,i.kt)("inlineCode",{parentName:"li"},"opcode = 2"),"), little-endian."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Push frequency"),": real-time"),(0,i.kt)("li",{parentName:"ul"},"Messages are delivered in-order per symbol group. A single packet may contain 1\u20131024 trades")),(0,i.kt)("h2",{id:"flow"},"Flow"),(0,i.kt)("h3",{id:"ping--pong-json-control-frames"},"Ping / Pong (JSON control frames)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Send Ping")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"req_id": "100001", "op": "ping"}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Receive Pong")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"success": true,"ret_msg": "pong","conn_id": "xxxxx-xx","req_id": "","op": "ping"}\n')),(0,i.kt)("h3",{id:"subscribe"},"Subscribe"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Topic format: ",(0,i.kt)("inlineCode",{parentName:"li"},"publicTrade.SBE.<symbol>"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Subscribe request")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"op": "subscribe","args": ["publicTrade.SBE.BTCUSDT"]}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Subscription confirmation")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "id": "trade-001",\n  "topic": "publicTrade.SBE.BTCUSDT",\n  "type": "snapshot",\n  "ts": 1760000000000,\n  "data": [...]\n}\n')),(0,i.kt)("h2",{id:"sbe-xml-template-public-trade"},"SBE XML Template (Public Trade)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8"?>\n<sbe:messageSchema xmlns:sbe="http://fixprotocol.io/2016/sbe" xmlns:mbx="https://bybit-exchange.github.io/docs/v5/intro" package="quote.sbe" id="1" version="0" semanticVersion="1.0.0" description="Bybit market data streams SBE message schema" byteOrder="littleEndian" headerType="messageHeader">\n  <types>\n    <composite name="messageHeader" description="Template ID and length of message root">\n <type name="blockLength" primitiveType="uint16"/>\n <type name="templateId" primitiveType="uint16"/>\n <type name="schemaId" primitiveType="uint16"/>\n <type name="version" primitiveType="uint16"/>\n    </composite>\n    <composite name="varString8" description="Variable length UTF-8 string.">\n <type name="length" primitiveType="uint8"/>\n <type name="varData" length="0" primitiveType="uint8" semanticType="String" characterEncoding="UTF-8"/>\n    </composite>\n    <enum name="SideType" encodingType="uint8">\n <validValue name="UNKNOWN">0</validValue>\n <validValue name="BUY">1</validValue>\n <validValue name="SELL">2</validValue>\n <validValue name="NON_REPRESENTABLE">254</validValue>\n    </enum>\n    <enum name="BoolEnum" encodingType="uint8">\n <validValue name="FALSE">0</validValue>\n <validValue name="TRUE">1</validValue>\n <validValue name="NON_REPRESENTABLE">254</validValue>\n    </enum>\n  </types>\n  \x3c!-- Stream event for "publicTrade.sbe.<symbol>" channel --\x3e\n  <sbe:message name="PublicTradeEvent" id="20002">\n    <field id="1" name="ts" type="int64" description="The timestamp in microseconds that the system generates the data"/>\n    <field id="2" name="priceExponent" type="int8" description="Price exponent for decimal point positioning"/>\n    <field id="3" name="sizeExponent" type="int8" description="Size exponent for decimal point positioning"/>\n    <group id="40" name="tradeItems" dimensionType="groupSize16Encoding" description="trade items">\n <field id="1" name="fillTime" type="int64" description="The timestamp in microseconds that the order is filled"/>\n <field id="2" name="price" type="int64" description="Price mantissa"/>\n <field id="3" name="size" type="int64" description="Size mantissa"/>\n <field id="4" name="seq" type="int64" description="Cross sequence ID"/>\n <field id="5" name="side" type="SideType" description="Side of taker"/>\n <field id="6" name="isBlockTrade" type="BoolEnum" description="Whether it is a block trade order or not"/>\n <field id="7" name="isRPI" type="BoolEnum" description="Whether it is a RPI trade or not"/>\n <field id="8" name="execId" type="int64" description="Trade ID"/>\n <data id="100" name="execIdString" type="varString8"/>\n    </group>\n    <data id="55" name="symbol" type="varString8"/>\n  </sbe:message>\n</sbe:messageSchema>\n')),(0,i.kt)("h2",{id:"field-reference"},"Field Reference"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Message:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"PublicTradeEvent")," (id = 20002)"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Field Name"),(0,i.kt)("th",{parentName:"tr",align:null},"ID"),(0,i.kt)("th",{parentName:"tr",align:null},"SBE Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Unit / Format"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ts"),(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"\xb5s"),(0,i.kt)("td",{parentName:"tr",align:null},"System generation time at push side (dispatcher).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"priceExponent"),(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"int8"),(0,i.kt)("td",{parentName:"tr",align:null},"exponent"),(0,i.kt)("td",{parentName:"tr",align:null},"Decimal places for price. Display price = priceMantissa \xd7 10^",(0,i.kt)("inlineCode",{parentName:"td"},"priceExponent"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sizeExponent"),(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"int8"),(0,i.kt)("td",{parentName:"tr",align:null},"exponent"),(0,i.kt)("td",{parentName:"tr",align:null},"Decimal places for size. Display size = sizeMantissa \xd7 10^",(0,i.kt)("inlineCode",{parentName:"td"},"sizeExponent"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tradeItems"),(0,i.kt)("td",{parentName:"tr",align:null},"40"),(0,i.kt)("td",{parentName:"tr",align:null},"group(",(0,i.kt)("inlineCode",{parentName:"td"},"groupSize16Encoding"),")"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"Repeating trade items")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"symbol"),(0,i.kt)("td",{parentName:"tr",align:null},"55"),(0,i.kt)("td",{parentName:"tr",align:null},"varString8"),(0,i.kt)("td",{parentName:"tr",align:null},"UTF-8"),(0,i.kt)("td",{parentName:"tr",align:null},"1-byte length + bytes, e.g., ",(0,i.kt)("inlineCode",{parentName:"td"},'0x07 "BTCUSDT"'),".")))),(0,i.kt)("h3",{id:"each-tradeitemsi-entry"},"Each tradeItems","[i]"," entry"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Field (id)"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"fillTime (1)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"Trade fill timestamp(\xb5s)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"price  (2)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"Apply priceExponent. Display ask size  = ",(0,i.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"size  (3)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"Apply sizeExponent. Display ask size  = ",(0,i.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"seq  (4)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"Cross sequence id")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"side  (5)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#sidetype"},"SideType"),"(uint8)"),(0,i.kt)("td",{parentName:"tr",align:null},"Side of taker")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"isBlockTrade  (6)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#boolenum"},"BoolEnum"),"(uint8)"),(0,i.kt)("td",{parentName:"tr",align:null},"IsBlockTrade(0 = not blockTrade, 1 = blockTrade)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"isRPI  (7)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#boolenum"},"BoolEnum"),"(uint8)"),(0,i.kt)("td",{parentName:"tr",align:null},"IsRPI (0 = not RPI, 1 = RPI)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"execId  (8)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"Trade ID")))),(0,i.kt)("h4",{id:"sidetype"},"SideType"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0"),": UNKOWN"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1"),": BUY"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2"),": SELL"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"254"),": NON_REPRESENTABLE")),(0,i.kt)("h4",{id:"boolenum"},"BoolEnum"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0"),": FALSE"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1"),": TRUE"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"254"),": NON_REPRESENTABLE")),(0,i.kt)("h2",{id:"integration-script"},"Integration Script"),(0,i.kt)("h3",{id:"python"},"Python"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import json\nimport struct\nimport websocket\nfrom typing import Tuple\n\nWS_URL = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\nSYMBOL = "BTCUSDT"\nTOPIC = f"publicTrade.sbe.{SYMBOL}"\n\n# ---------------- SBE helpers ----------------\n\ndef apply_exp(mantissa: int, exp: int) -> float:\n    # display = mantissa * 10^exp\n    # exp can be negative\n    return mantissa * (10.0 ** exp)\n\ndef read_varstring8(buf: bytes, off: int) -> Tuple[str, int]:\n    if off + 1 > len(buf):\n   raise ValueError("varString8: missing length")\n    ln = buf[off]\n    off += 1\n    if off + ln > len(buf):\n   raise ValueError("varString8: out of range")\n    s = buf[off:off+ln].decode("utf-8", errors="replace")\n    off += ln\n    return s, off\n\ndef parse_public_trade_event(buf: bytes) -> dict:\n    # messageHeader: <HHHH\n    if len(buf) < 8:\n   raise ValueError("too short for header")\n    block_len, template_id, schema_id, version = struct.unpack_from("<HHHH", buf, 0)\n    off = 8\n\n    if template_id != 20002:\n   raise ValueError(f"unexpected templateId={template_id}")\n\n    # fixed fields: ts(int64), priceExp(int8), sizeExp(int8)\n    if len(buf) < off + 8 + 1 + 1:\n   raise ValueError("too short for fixed fields")\n    ts = struct.unpack_from("<q", buf, off)[0]; off += 8\n    price_exp = struct.unpack_from("<b", buf, off)[0]; off += 1\n    size_exp  = struct.unpack_from("<b", buf, off)[0]; off += 1\n\n    # group header: blockLength(uint16), numInGroup(uint16)\n    if len(buf) < off + 4:\n   raise ValueError("too short for group header")\n    grp_block_len, num_in_group = struct.unpack_from("<HH", buf, off)\n    off += 4\n\n    trades = []\n    for _ in range(num_in_group):\n   entry_start = off\n\n   # Parse fields in-order (don\u2019t assume padding; only skip remaining bytes up to grp_block_len)\n   fill_time = struct.unpack_from("<q", buf, off)[0]; off += 8\n   price_m   = struct.unpack_from("<q", buf, off)[0]; off += 8\n   size_m    = struct.unpack_from("<q", buf, off)[0]; off += 8\n   seq  = struct.unpack_from("<q", buf, off)[0]; off += 8\n\n   side = struct.unpack_from("<B", buf, off)[0]; off += 1\n   is_block = struct.unpack_from("<B", buf, off)[0]; off += 1\n   is_rpi   = struct.unpack_from("<B", buf, off)[0]; off += 1\n\n   exec_id = struct.unpack_from("<q", buf, off)[0]; off += 8\n\n   # Skip any future extension bytes in fixed part\n   fixed_consumed = off - entry_start\n   if fixed_consumed < grp_block_len:\noff += (grp_block_len - fixed_consumed)\n   elif fixed_consumed > grp_block_len:\n# schema mismatch vs blockLength\nraise ValueError(f"group blockLength too small: {grp_block_len} < {fixed_consumed}")\n\n   exec_id_str, off = read_varstring8(buf, off)\n\n   trades.append({\n"fillTime": fill_time,\n"priceMantissa": price_m,\n"sizeMantissa": size_m,\n"price": apply_exp(price_m, price_exp),\n"size": apply_exp(size_m, size_exp),\n"seq": seq,\n"side": side,\n"isBlockTrade": bool(is_block),\n"isRPI": bool(is_rpi),\n"execId": exec_id,\n"execIdString": exec_id_str,\n   })\n\n    symbol, off = read_varstring8(buf, off)\n\n    return {\n   "header": {\n"blockLength": block_len,\n"templateId": template_id,\n"schemaId": schema_id,\n"version": version,\n   },\n   "ts": ts,\n   "priceExponent": price_exp,\n   "sizeExponent": size_exp,\n   "symbol": symbol,\n   "tradeItems": trades,\n   "parsed_length": off,\n    }\n\n# ---------------- WS handlers ----------------\n\ndef on_open(ws):\n    ws.send(json.dumps({"op": "subscribe", "args": [TOPIC]}))\n    print("subscribed:", TOPIC)\n\ndef on_message(ws, message):\n    if isinstance(message, (bytes, bytearray)):\n   evt = parse_public_trade_event(message)\n   # print first trade only (example)\n   if evt["tradeItems"]:\nt0 = evt["tradeItems"][0]\nprint(evt["symbol"], "trades=", len(evt["tradeItems"]),\n "first:", t0["price"], "@", t0["size"], "seq=", t0["seq"])\n    else:\n   print("TEXT:", message)\n\ndef on_error(ws, err):\n    print("WS error:", err)\n\ndef on_close(ws, *_):\n    print("closed")\n\nif __name__ == "__main__":\n    websocket.enableTrace(False)\n    ws = websocket.WebSocketApp(\n   WS_URL, on_open=on_open, on_message=on_message,\n   on_error=on_error, on_close=on_close\n    )\n    ws.run_forever(ping_interval=20, ping_timeout=10)\n    \n')),(0,i.kt)("h3",{id:"golang"},"Golang"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n   "encoding/binary"\n   "encoding/json"\n   "fmt"\n   "log"\n   "math"\n   "time"\n\n   "github.com/gorilla/websocket"\n)\n\nconst (\n   WSURL  = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\n   Symbol = "BTCUSDT"\n   Topic  = "publicTrade.sbe." + Symbol\n)\n\nfunc applyExp(mantissa int64, exp int8) float64 {\n   return float64(mantissa) * math.Pow10(int(exp))\n}\n\nfunc readVarString8(buf []byte, off int) (string, int, error) {\n   if off+1 > len(buf) {\n    return "", off, fmt.Errorf("varString8: missing length")\n   }\n   ln := int(buf[off])\n   off++\n   if off+ln > len(buf) {\n    return "", off, fmt.Errorf("varString8: out of range")\n   }\n   s := string(buf[off : off+ln])\n   off += ln\n   return s, off, nil\n}\n\ntype TradeItem struct {\n   FillTimeint64   `json:"fillTime"`\n   PriceMant    int64   `json:"priceMantissa"`\n   SizeMantint64   `json:"sizeMantissa"`\n   Price   float64 `json:"price"`\n   Size    float64 `json:"size"`\n   Seqint64   `json:"seq"`\n   Side    uint8   `json:"side"`\n   IsBlockTrade bool    `json:"isBlockTrade"`\n   IsRPI   bool    `json:"isRPI"`\n   ExecID  int64   `json:"execId"`\n   ExecIDString string  `json:"execIdString"`\n}\n\ntype PublicTradeEvent struct {\n   Header struct {\n    BlockLength uint16 `json:"blockLength"`\n    TemplateID  uint16 `json:"templateId"`\n    SchemaID    uint16 `json:"schemaId"`\n    Versionuint16 `json:"version"`\n   } `json:"header"`\n\n   Tsint64  `json:"ts"`\n   PriceExponent int8   `json:"priceExponent"`\n   SizeExponent  int8   `json:"sizeExponent"`\n   TradeItems    []TradeItem `json:"tradeItems"`\n   Symbol   string `json:"symbol"`\n   ParsedLength  int    `json:"parsed_length"`\n}\n\nfunc parsePublicTradeEvent(buf []byte) (*PublicTradeEvent, error) {\n   if len(buf) < 8 {\n    return nil, fmt.Errorf("too short for header")\n   }\n   off := 0\n   blk := binary.LittleEndian.Uint16(buf[off : off+2])\n   tid := binary.LittleEndian.Uint16(buf[off+2 : off+4])\n   sid := binary.LittleEndian.Uint16(buf[off+4 : off+6])\n   ver := binary.LittleEndian.Uint16(buf[off+6 : off+8])\n   off += 8\n\n   if tid != 20002 {\n    return nil, fmt.Errorf("unexpected templateId=%d", tid)\n   }\n   if off+8+1+1 > len(buf) {\n    return nil, fmt.Errorf("too short for fixed fields")\n   }\n   ts := int64(binary.LittleEndian.Uint64(buf[off : off+8]))\n   off += 8\n   priceExp := int8(buf[off])\n   off++\n   sizeExp := int8(buf[off])\n   off++\n\n   // group header\n   if off+4 > len(buf) {\n    return nil, fmt.Errorf("too short for group header")\n   }\n   grpBlockLen := binary.LittleEndian.Uint16(buf[off : off+2])\n   numInGroup := binary.LittleEndian.Uint16(buf[off+2 : off+4])\n   off += 4\n\n   items := make([]TradeItem, 0, int(numInGroup))\n   for i := 0; i < int(numInGroup); i++ {\n    entryStart := off\n\n    needMin := 8 + 8 + 8 + 8 + 1 + 1 + 1 + 8\n    if off+needMin > len(buf) {\nreturn nil, fmt.Errorf("too short for trade entry %d", i)\n    }\n\n    fillTime := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n    priceM := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n    sizeM := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n    seq := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n\n    side := uint8(buf[off]); off++\n    isBlock := uint8(buf[off]); off++\n    isRpi := uint8(buf[off]); off++\n\n    execID := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n\n    fixedConsumed := off - entryStart\n    if fixedConsumed < int(grpBlockLen) {\noff += int(grpBlockLen) - fixedConsumed\n    } else if fixedConsumed > int(grpBlockLen) {\nreturn nil, fmt.Errorf("group blockLength too small: %d < %d", grpBlockLen, fixedConsumed)\n    }\n\n    execIDStr, off2, err := readVarString8(buf, off)\n    if err != nil {\nreturn nil, err\n    }\n    off = off2\n\n    items = append(items, TradeItem{\nFillTime:fillTime,\nPriceMant:    priceM,\nSizeMant:sizeM,\nPrice:   applyExp(priceM, priceExp),\nSize:    applyExp(sizeM, sizeExp),\nSeq:seq,\nSide:    side,\nIsBlockTrade: isBlock != 0,\nIsRPI:   isRpi != 0,\nExecID:  execID,\nExecIDString: execIDStr,\n    })\n   }\n\n   symbol, off2, err := readVarString8(buf, off)\n   if err != nil {\n    return nil, err\n   }\n   off = off2\n\n   evt := &PublicTradeEvent{\n    Ts:ts,\n    PriceExponent: priceExp,\n    SizeExponent:  sizeExp,\n    TradeItems:    items,\n    Symbol:   symbol,\n    ParsedLength:  off,\n   }\n   evt.Header.BlockLength = blk\n   evt.Header.TemplateID = tid\n   evt.Header.SchemaID = sid\n   evt.Header.Version = ver\n   return evt, nil\n}\n\nfunc main() {\n   d := websocket.Dialer{HandshakeTimeout: 10 * time.Second}\n   c, _, err := d.Dial(WSURL, nil)\n   if err != nil {\n    log.Fatal(err)\n   }\n   defer c.Close()\n\n   sub, _ := json.Marshal(map[string]any{"op": "subscribe", "args": []string{Topic}})\n   if err := c.WriteMessage(websocket.TextMessage, sub); err != nil {\n    log.Fatal(err)\n   }\n   log.Println("subscribed:", Topic)\n\n   for {\n    mt, msg, err := c.ReadMessage()\n    if err != nil {\nlog.Fatal(err)\n    }\n    if mt == websocket.BinaryMessage {\nevt, err := parsePublicTradeEvent(msg)\nif err != nil {\n   log.Println("decode error:", err)\n   continue\n}\nif len(evt.TradeItems) > 0 {\n   t0 := evt.TradeItems[0]\n   log.Printf("%s trades=%d first=%.8f@%.8f seq=%d",\n    evt.Symbol, len(evt.TradeItems), t0.Price, t0.Size, t0.Seq)\n}\n    } else {\nlog.Println("TEXT:", string(msg))\n    }\n   }\n}\n')))}f.isMDXComponent=!0}}]);