"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[4754],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>c});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(t),c=r,k=m["".concat(o,".").concat(c)]||m[c]||u[c]||l;return t?a.createElement(k,i(i({ref:n},d),{},{components:t})):a.createElement(k,i({ref:n},d))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},43779:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const l={title:"SBE Level 50 Integration",sidebar_label:"SBE Level 50 Integration",sidebar_position:1},i=void 0,s={unversionedId:"v5/sbe/level-50/sbe-level-50",id:"v5/sbe/level-50/sbe-level-50",title:"SBE Level 50 Integration",description:"Overview",source:"@site/docs/v5/sbe/level-50/sbe-level-50.mdx",sourceDirName:"v5/sbe/level-50",slug:"/v5/sbe/level-50/sbe-level-50",permalink:"/docs/v5/sbe/level-50/sbe-level-50",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"SBE Level 50 Integration",sidebar_label:"SBE Level 50 Integration",sidebar_position:1},sidebar:"v5SideBar",previous:{title:"SBE BBO Integration",permalink:"/docs/v5/sbe/bbo/sbe-bbo"},next:{title:"SBE Public Trade Integration",permalink:"/docs/v5/sbe/sbe-public-trade/"}},o={},p=[{value:"Overview",id:"overview",level:2},{value:"SBE Connection Limit",id:"sbe-connection-limit",level:2},{value:"Flow",id:"flow",level:2},{value:"Ping / Pong (JSON control frames)",id:"ping--pong-json-control-frames",level:3},{value:"Subscribe",id:"subscribe",level:3},{value:"SBE XML Template (L50 OB)",id:"sbe-xml-template-l50-ob",level:2},{value:"Field Reference",id:"field-reference",level:2},{value:"Asks Group",id:"asks-group",level:3},{value:"Bids Group",id:"bids-group",level:3},{value:"Order Book Update Logic",id:"order-book-update-logic",level:2},{value:"Rules for the u (Update ID) Field",id:"rules-for-the-u-update-id-field",level:3},{value:"Behavior of <code>u</code>",id:"behavior-of-u",level:4},{value:"Continuity Validation",id:"continuity-validation",level:4},{value:"Rules for Order Book Maintenance",id:"rules-for-order-book-maintenance",level:3},{value:"First Message of connection and reconnection",id:"first-message-of-connection-and-reconnection",level:4},{value:"Snapshot Handling",id:"snapshot-handling",level:4},{value:"Delta Handling",id:"delta-handling",level:4},{value:"Example Push Update",id:"example-push-update",level:3},{value:"Integration Script",id:"integration-script",level:2},{value:"Python",id:"python",level:3},{value:"Golang",id:"golang",level:3}],d={toc:p};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Channel:")," private MMWS only (not available on public WS)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Topic:")," ",(0,r.kt)("inlineCode",{parentName:"li"},"ob.50.sbe.{symbol}")," (snapshot or delta, every 20 ms)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Format:")," SBE binary frames (",(0,r.kt)("inlineCode",{parentName:"li"},"opcode = 2"),"), little-endian."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Depth:")," 50 levels per side (no RPI in this stream)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Units:")," timestamps in microseconds (\xb5s); price/size are mantissas with exponents.")),(0,r.kt)("h2",{id:"sbe-connection-limit"},"SBE Connection Limit"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Spot:")," 1500 connections limit per dedicated MMWS host."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Futures (linear + inverse):")," 3000 connections limit per dedicated MMWS host."),(0,r.kt)("li",{parentName:"ul"},"Once you breach the connection limit, new connections return ",(0,r.kt)("strong",{parentName:"li"},"HTTP 429"),".")),(0,r.kt)("h2",{id:"flow"},"Flow"),(0,r.kt)("h3",{id:"ping--pong-json-control-frames"},"Ping / Pong (JSON control frames)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Send Ping")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"req_id": "100001", "op": "ping"}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Receive Pong")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"success": true,"ret_msg": "pong","conn_id": "xxxxx-xx","req_id": "","op": "ping"}\n')),(0,r.kt)("h3",{id:"subscribe"},"Subscribe"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Topic format: ",(0,r.kt)("inlineCode",{parentName:"li"},"ob.50.sbe.<symbol>"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Subscribe request")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"op": "subscribe", "args": ["ob.50.sbe.BTCUSDT"]}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Subscription confirmation")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"success": true,"ret_msg": "","conn_id": "d30fdpbboasp1pjbe7r0","req_id": "xxx","op": "subscribe"}\n')),(0,r.kt)("h2",{id:"sbe-xml-template-l50-ob"},"SBE XML Template (L50 OB)"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"../sbe-basic-info#sbe-xml-template"},"sbe xml template")),(0,r.kt)("h2",{id:"field-reference"},"Field Reference"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Message:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"OBL50Event")," (id = 20001)"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field Name"),(0,r.kt)("th",{parentName:"tr",align:null},"ID"),(0,r.kt)("th",{parentName:"tr",align:null},"SBE Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Unit / Format"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ts"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"\xb5s"),(0,r.kt)("td",{parentName:"tr",align:null},"System generation time at push side (dispatcher).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"seq"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Cross-sequence id (monotonic per feed; not guaranteed continuous).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cts"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"\xb5s"),(0,r.kt)("td",{parentName:"tr",align:null},"Matching-engine creation time of this OB snapshot or delta; used for latency measurements.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"u"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Update id (monotonic per symbol). Useful to check continuity.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"priceExponent"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"int8"),(0,r.kt)("td",{parentName:"tr",align:null},"exponent"),(0,r.kt)("td",{parentName:"tr",align:null},"Decimal places for price. Display price = mantissa \xd7 10^",(0,r.kt)("inlineCode",{parentName:"td"},"priceExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sizeExponent"),(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"int8"),(0,r.kt)("td",{parentName:"tr",align:null},"exponent"),(0,r.kt)("td",{parentName:"tr",align:null},"Decimal places for size. Display size = mantissa \xd7 10^",(0,r.kt)("inlineCode",{parentName:"td"},"sizeExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pkgType"),(0,r.kt)("td",{parentName:"tr",align:null},"7"),(0,r.kt)("td",{parentName:"tr",align:null},"uint8 (",(0,r.kt)("inlineCode",{parentName:"td"},"pkgTypeEnum"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"integer"),(0,r.kt)("td",{parentName:"tr",align:null},"Package type (0 = snapshot, 1 = delta).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"asks"),(0,r.kt)("td",{parentName:"tr",align:null},"40"),(0,r.kt)("td",{parentName:"tr",align:null},"group(",(0,r.kt)("inlineCode",{parentName:"td"},"groupSize16Encoding"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014"),(0,r.kt)("td",{parentName:"tr",align:null},"Sell side updates (up to 50 levels).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bids"),(0,r.kt)("td",{parentName:"tr",align:null},"41"),(0,r.kt)("td",{parentName:"tr",align:null},"group(",(0,r.kt)("inlineCode",{parentName:"td"},"groupSize16Encoding"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014"),(0,r.kt)("td",{parentName:"tr",align:null},"Buy side updates (up to 50 levels).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"symbol"),(0,r.kt)("td",{parentName:"tr",align:null},"55"),(0,r.kt)("td",{parentName:"tr",align:null},"varString8"),(0,r.kt)("td",{parentName:"tr",align:null},"UTF-8"),(0,r.kt)("td",{parentName:"tr",align:null},"1-byte length + bytes, e.g., ",(0,r.kt)("inlineCode",{parentName:"td"},'0x07 "BTCUSDT"'),".")))),(0,r.kt)("h3",{id:"asks-group"},"Asks Group"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field (id)"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"price (1)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Ask price mantissa. Display ask price = ",(0,r.kt)("inlineCode",{parentName:"td"},"price \xd7 10^priceExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"size  (2)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Ask size mantissa. Display ask size  = ",(0,r.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")))),(0,r.kt)("h3",{id:"bids-group"},"Bids Group"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field (id)"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"price (1)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Bid price mantissa. Display bid price = ",(0,r.kt)("inlineCode",{parentName:"td"},"price \xd7 10^priceExponent"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"size  (2)"),(0,r.kt)("td",{parentName:"tr",align:null},"int64"),(0,r.kt)("td",{parentName:"tr",align:null},"Bid size mantissa. Display bid size  = ",(0,r.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),".")))),(0,r.kt)("h2",{id:"order-book-update-logic"},"Order Book Update Logic"),(0,r.kt)("h3",{id:"rules-for-the-u-update-id-field"},"Rules for the u (Update ID) Field"),(0,r.kt)("h4",{id:"behavior-of-u"},"Behavior of ",(0,r.kt)("inlineCode",{parentName:"h4"},"u")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Field ",(0,r.kt)("inlineCode",{parentName:"li"},"u")," ",(0,r.kt)("strong",{parentName:"li"},"increases monotonically")," for all snapshots and deltas."),(0,r.kt)("li",{parentName:"ul"},"Field ",(0,r.kt)("inlineCode",{parentName:"li"},"u")," ",(0,r.kt)("strong",{parentName:"li"},"does not reset"),", unless there is a system reset or precision change."),(0,r.kt)("li",{parentName:"ul"},"Field ",(0,r.kt)("inlineCode",{parentName:"li"},"u = 1")," always indicates a ",(0,r.kt)("strong",{parentName:"li"},"snapshot"),", and continuity checks must stop.")),(0,r.kt)("h4",{id:"continuity-validation"},"Continuity Validation"),(0,r.kt)("p",null,"Continuity must be checked ",(0,r.kt)("strong",{parentName:"p"},"only when ",(0,r.kt)("inlineCode",{parentName:"strong"},"u != 1")),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Condition"),(0,r.kt)("th",{parentName:"tr",align:null},"Action"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u != 1")),(0,r.kt)("td",{parentName:"tr",align:null},"Validate continuity: next ",(0,r.kt)("inlineCode",{parentName:"td"},"u")," should follow previous ",(0,r.kt)("inlineCode",{parentName:"td"},"u + 1"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"u == 1")),(0,r.kt)("td",{parentName:"tr",align:null},"Special snapshot (service restart / precision change). ",(0,r.kt)("strong",{parentName:"td"},"Do not")," perform continuity checks.")))),(0,r.kt)("h3",{id:"rules-for-order-book-maintenance"},"Rules for Order Book Maintenance"),(0,r.kt)("h4",{id:"first-message-of-connection-and-reconnection"},"First Message of connection and reconnection"),(0,r.kt)("p",null,"After subscribing, the ",(0,r.kt)("strong",{parentName:"p"},"first message is always a snapshot"),", clients must initialize the local book with it."),(0,r.kt)("h4",{id:"snapshot-handling"},"Snapshot Handling"),(0,r.kt)("p",null,"A snapshot must always ",(0,r.kt)("strong",{parentName:"p"},"replace the entire local order book")),(0,r.kt)("p",null,"Snapshots may appear:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"after initial subscription"),(0,r.kt)("li",{parentName:"ul"},"when the number of changed levels > 100 (extreme market condition auto-fallback)"),(0,r.kt)("li",{parentName:"ul"},"after internal service restart"),(0,r.kt)("li",{parentName:"ul"},"after exponent / precision changes")),(0,r.kt)("h4",{id:"delta-handling"},"Delta Handling"),(0,r.kt)("p",null,"A delta applies ",(0,r.kt)("strong",{parentName:"p"},"incrementally"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Insert/update levels with ",(0,r.kt)("inlineCode",{parentName:"li"},"size > 0"),",remove levels when ",(0,r.kt)("inlineCode",{parentName:"li"},"size == 0"),",continue continuity checks using the ",(0,r.kt)("inlineCode",{parentName:"li"},"u")," field.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Extreme Market Condition Handling")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When a delta contains ",(0,r.kt)("strong",{parentName:"li"},"more than 100 combined bid+ask updates")," (buy + sell), the system automatically sends a ",(0,r.kt)("strong",{parentName:"li"},"full snapshot")," instead of a delta."),(0,r.kt)("li",{parentName:"ul"},"Ensures client books resync cleanly."),(0,r.kt)("li",{parentName:"ul"},"Prevents explosion of delta packets during high churn."),(0,r.kt)("li",{parentName:"ul"},"Keeps snapshot size fixed length for predictable decoding.")),(0,r.kt)("h3",{id:"example-push-update"},"Example Push Update"),(0,r.kt)("p",null,"Below is a real case where the connection stays healthy and messages arrive in order:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"u"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10000"),(0,r.kt)("td",{parentName:"tr",align:null},"snapshot"),(0,r.kt)("td",{parentName:"tr",align:null},"First message after subscription.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10001"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"Incremental updates. Must ",(0,r.kt)("strong",{parentName:"td"},"apply changes")," to the existing book.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10002"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"Normal incremental update.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10003"),(0,r.kt)("td",{parentName:"tr",align:null},"snapshot"),(0,r.kt)("td",{parentName:"tr",align:null},"Large market move (> 100 level changes). Use snapshot to ",(0,r.kt)("strong",{parentName:"td"},"replace")," local book.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10004"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"Continue delta from the new snapshot.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"snapshot"),(0,r.kt)("td",{parentName:"tr",align:null},"Service restarted / precision changed \u2014 reset ",(0,r.kt)("inlineCode",{parentName:"td"},"u")," to 1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"New continuity sequence.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"delta"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2014")))),(0,r.kt)("h2",{id:"integration-script"},"Integration Script"),(0,r.kt)("h3",{id:"python"},"Python"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import json\nimport logging\nimport struct\nimport threading\nimport time\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Tuple\n\nimport websocket\n\nlogging.basicConfig(\n    filename=\'logfile_ob50.log\',\n    level=logging.INFO,\n    format=\'%(asctime)s %(levelname)s %(message)s\'\n)\n\n# -------------------------------------------------------------------\n# Config\n# -------------------------------------------------------------------\n\n# L50 SBE order book topic\nTOPIC = "ob.50.sbe.BTCUSDT"\n\n# Adjust URL for spot / contract environment as needed:\nWS_URL = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\n\n# -------------------------------------------------------------------\n# SBE Parser for OBL50Event (template_id = 20001)\n#\n# XML schema:\n#   ts(int64), seq(int64), cts(int64), u(int64),\n#   priceExponent(int8), sizeExponent(int8),\n#   pkgType(uint8)   # 0 = SNAPSHOT, 1 = DELTA\n#   group asks: blockLen(uint16), numInGroup(uint16),\n#               then numInGroup * [ price(int64), size(int64) ]\n#   group bids: same as asks\n#   symbol(varString8)\n# -------------------------------------------------------------------\n\nclass SBEOBL50Parser:\n    def __init__(self):\n        # message header: blockLength, templateId, schemaId, version\n        self.header_fmt = "<HHHH"\n        self.header_sz = struct.calcsize(self.header_fmt)\n\n        # fixed body fields:\n        # ts, seq, cts, u   -> 4 x int64\n        # priceExponent, sizeExponent -> 2 x int8\n        # pkgType -> uint8\n        self.body_fmt = "<qqqqbbB"   # 4*q + 2*b + B\n        self.body_sz = struct.calcsize(self.body_fmt)\n\n        # group header for repeating groups: blockLength(uint16), numInGroup(uint16)\n        self.group_hdr_fmt = "<HH"\n        self.group_hdr_sz = struct.calcsize(self.group_hdr_fmt)\n\n        # each group entry: price(int64), size(int64)\n        self.level_fmt = "<qq"\n        self.level_sz = struct.calcsize(self.level_fmt)\n\n        self.target_template_id = 20001\n\n    # ---------------- core small helpers ----------------\n\n    def _parse_header(self, data: bytes) -> Dict[str, Any]:\n        if len(data) < self.header_sz:\n            raise ValueError("insufficient data for SBE header")\n        block_length, template_id, schema_id, version = struct.unpack_from(\n            self.header_fmt, data, 0\n        )\n        return {\n            "block_length": block_length,\n            "template_id": template_id,\n            "schema_id": schema_id,\n            "version": version,\n        }\n\n    @staticmethod\n    def _parse_varstring8(data: bytes, offset: int) -> Tuple[str, int]:\n        if offset + 1 > len(data):\n            raise ValueError("insufficient data for varString8 length")\n        (length,) = struct.unpack_from("<B", data, offset)\n        offset += 1\n        if length == 0:\n            return "", offset\n        if offset + length > len(data):\n            raise ValueError("insufficient data for varString8 bytes")\n        s = data[offset: offset + length].decode("utf-8")\n        offset += length\n        return s, offset\n\n    @staticmethod\n    def _apply_exponent(value: int, exponent: int) -> float:\n        return value / (10 ** exponent) if exponent >= 0 else value * (10 ** (-exponent))\n\n    def _parse_levels(self, data: bytes, offset: int) -> Tuple[List[Dict[str, float]], int]:\n        """\n        Parse one repeating group (asks or bids).\n        Layout:\n           uint16 blockLength\n           uint16 numInGroup\n           numInGroup * [ price(int64), size(int64) ] (within blockLength)\n        """\n        if offset + self.group_hdr_sz > len(data):\n            raise ValueError("insufficient data for group header")\n        block_len, num_in_group = struct.unpack_from(self.group_hdr_fmt, data, offset)\n        offset += self.group_hdr_sz\n\n        if block_len < self.level_sz:\n            raise ValueError(f"blockLength({block_len}) < level_sz({self.level_sz})")\n\n        levels = []\n        for _ in range(num_in_group):\n            if offset + block_len > len(data):\n                raise ValueError("insufficient data for group entry")\n            # we only care about first 16 bytes (price, size)\n            price_m, size_m = struct.unpack_from(self.level_fmt, data, offset)\n            offset += block_len  # skip the whole block (safe if future adds extra fields)\n\n            levels.append({\n                "price_m": price_m,\n                "size_m": size_m,\n            })\n        return levels, offset\n\n    # ---------------- public parse ----------------\n\n    def parse(self, data: bytes) -> Dict[str, Any]:\n        hdr = self._parse_header(data)\n        if hdr["template_id"] != self.target_template_id:\n            raise NotImplementedError(f"unsupported template_id={hdr[\'template_id\']}")\n\n        if len(data) < self.header_sz + self.body_sz:\n            raise ValueError("insufficient data for OBL50Event body")\n\n        # parse fixed body\n        (ts, seq, cts, u,\n         price_exp, size_exp, pkg_type) = struct.unpack_from(\n            self.body_fmt, data, self.header_sz\n        )\n\n        offset = self.header_sz + self.body_sz\n\n        # asks group\n        asks_raw, offset = self._parse_levels(data, offset)\n        # bids group\n        bids_raw, offset = self._parse_levels(data, offset)\n        # symbol\n        symbol, offset = self._parse_varstring8(data, offset)\n\n        # apply exponents\n        asks = [\n            {\n                "price": self._apply_exponent(l["price_m"], price_exp),\n                "size": self._apply_exponent(l["size_m"], size_exp),\n            }\n            for l in asks_raw\n        ]\n        bids = [\n            {\n                "price": self._apply_exponent(l["price_m"], price_exp),\n                "size": self._apply_exponent(l["size_m"], size_exp),\n            }\n            for l in bids_raw\n        ]\n\n        return {\n            "header": hdr,\n            "ts": ts,\n            "seq": seq,\n            "cts": cts,\n            "u": u,\n            "price_exponent": price_exp,\n            "size_exponent": size_exp,\n            "pkg_type": pkg_type,   # 0 = SNAPSHOT, 1 = DELTA\n            "symbol": symbol,\n            "asks": asks,\n            "bids": bids,\n            "parsed_length": offset,\n        }\n\n\nparser = SBEOBL50Parser()\n\n# -------------------------------------------------------------------\n# WebSocket handlers\n# -------------------------------------------------------------------\n\ndef on_message(ws, message):\n    try:\n        if isinstance(message, (bytes, bytearray)):\n            decoded = parser.parse(message)\n\n            pkg_type = decoded["pkg_type"]\n            pkg_str = "SNAPSHOT" if pkg_type == 0 else "DELTA" if pkg_type == 1 else f"UNKNOWN({pkg_type})"\n\n            asks = decoded["asks"]\n            bids = decoded["bids"]\n\n            best_ask = asks[0] if asks else {"price": 0.0, "size": 0.0}\n            best_bid = bids[0] if bids else {"price": 0.0, "size": 0.0}\n\n            logging.info(\n                "SBE %s u=%s seq=%s type=%s asks=%d bids=%d "\n                "BEST bid=%.8f@%.8f ask=%.8f@%.8f ts=%s",\n                decoded["symbol"], decoded["u"], decoded["seq"], pkg_str,\n                len(asks), len(bids),\n                best_bid["price"], best_bid["size"],\n                best_ask["price"], best_ask["size"],\n                decoded["ts"],\n            )\n\n            print(\n                f"{decoded[\'symbol\']}  u={decoded[\'u\']}  seq={decoded[\'seq\']}  {pkg_str}  "\n                f"levels: asks={len(asks)} bids={len(bids)}  "\n                f"BEST: bid {best_bid[\'price\']:.8f} x {best_bid[\'size\']:.8f}  |  "\n                f"ask {best_ask[\'price\']:.8f} x {best_ask[\'size\']:.8f}"\n            )\n\n        else:\n            # text frame: control / errors / ping-pong\n            try:\n                obj = json.loads(message)\n                logging.info("TEXT %s", obj)\n                print("TEXT:", obj)\n            except json.JSONDecodeError:\n                logging.warning("non-JSON text frame: %r", message)\n                print("TEXT(non-json):", message)\n    except Exception as e:\n        logging.exception("decode error: %s", e)\n        print("decode error:", e)\n\n\ndef on_error(ws, error):\n    print("WS error:", error)\n    logging.error("WS error: %s", error)\n\n\ndef on_close(ws, *_):\n    print("### connection closed ###")\n    logging.info("connection closed")\n\n\ndef ping_per(ws):\n    while True:\n        try:\n            ws.send(json.dumps({"op": "ping"}))\n        except Exception:\n            return\n        time.sleep(10)\n\n\ndef on_open(ws):\n    print("opened")\n    sub = {"op": "subscribe", "args": [TOPIC]}\n    ws.send(json.dumps(sub))\n    print("subscribed:", TOPIC)\n\n    # background ping thread\n    threading.Thread(target=ping_per, args=(ws,), daemon=True).start()\n\n\ndef on_pong(ws, *_):\n    print("pong received")\n\n\ndef on_ping(ws, *_):\n    print("ping received @", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))\n\n\ndef connWS():\n    ws = websocket.WebSocketApp(\n        WS_URL,\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n        on_ping=on_ping,\n        on_pong=on_pong,\n    )\n    ws.run_forever(ping_interval=20, ping_timeout=10)\n\n\nif __name__ == "__main__":\n    websocket.enableTrace(False)\n    connWS()\n    \n')),(0,r.kt)("h3",{id:"golang"},"Golang"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// sbe_ob50_client.go\npackage main\n\nimport (\n    "bytes"\n    "compress/flate"\n    "encoding/binary"\n    "encoding/json"\n    "fmt"\n    "log"\n    "math"\n    "time"\n\n    "github.com/gorilla/websocket"\n    "yourmodule/quote" // generated SBE package\n)\n\nconst (\n    WSURL   = "wss://stream.bybit.com/v5/market/sbe"\n    CHANNEL = "ob.50.sbe.BTCUSDT"\n)\n\nfunc toReal(mantissa int64, exponent int8) float64 {\n    return float64(mantissa) * math.Pow10(int(exponent))\n}\n\nfunc decodeOBL50(buf []byte) (*quote.OBL50Event, error) {\n    var hdr quote.MessageHeader\n    reader := bytes.NewReader(buf)\n\n    // decode messageHeader (little endian)\n    if err := binary.Read(reader, binary.LittleEndian, &hdr); err != nil {\n        return nil, fmt.Errorf("read header: %w", err)\n    }\n\n    if hdr.TemplateId != 20001 {\n        return nil, fmt.Errorf("unexpected templateId: %d", hdr.TemplateId)\n    }\n\n    var msg quote.OBL50Event\n    // many generators provide WrapForDecode; here assume we can read the fixed block then groups\n    if err := msg.Decode(reader, int(hdr.BlockLength), int(hdr.Version)); err != nil {\n        return nil, fmt.Errorf("decode OBL50: %w", err)\n    }\n\n    return &msg, nil\n}\n\nfunc main() {\n    book := NewOrderBook()\n\n    dialer := websocket.Dialer{\n        HandshakeTimeout: 10 * time.Second,\n        EnableCompression: false,\n    }\n\n    conn, _, err := dialer.Dial(WSURL, nil)\n    if err != nil {\n        log.Fatalf("dial: %v", err)\n    }\n    defer conn.Close()\n\n    // subscribe\n    sub := map[string]interface{}{\n        "op":   "subscribe",\n        "args": []string{CHANNEL},\n    }\n    if err := conn.WriteJSON(sub); err != nil {\n        log.Fatalf("subscribe: %v", err)\n    }\n\n    for {\n        mt, data, err := conn.ReadMessage()\n        if err != nil {\n            log.Fatalf("read: %v", err)\n        }\n\n        if mt == websocket.TextMessage {\n            // control JSON or pong etc\n            var m map[string]interface{}\n            _ = json.Unmarshal(data, &m)\n            continue\n        }\n\n        // if server wraps SBE in per-message deflate, you may need to decompress:\n        if isDeflatedFrame(data) {\n            data, err = inflate(data)\n            if err != nil {\n                log.Printf("inflate error: %v", err)\n                continue\n            }\n        }\n\n        msg, err := decodeOBL50(data)\n        if err != nil {\n            log.Printf("decode error: %v", err)\n            continue\n        }\n\n        u := msg.U\n        pkgType := msg.PkgType // 0 snapshot, 1 delta\n        pxExp := msg.PriceExponent\n        szExp := msg.SizeExponent\n\n        // extract levels\n        var asks, bids [][2]float64\n        for _, a := range msg.Asks {\n            p := toReal(a.Price, pxExp)\n            sz := toReal(a.Size, szExp)\n            asks = append(asks, [2]float64{p, sz})\n        }\n        for _, b := range msg.Bids {\n            p := toReal(b.Price, pxExp)\n            sz := toReal(b.Size, szExp)\n            bids = append(bids, [2]float64{p, sz})\n        }\n\n        // continuity logic:\n        if u == 1 {\n            // service restart / precision change snapshot\n            book.Asks.SnapshotFrom(asks)\n            book.Bids.SnapshotFrom(bids)\n            book.LastU = 1\n            fmt.Printf("[RESET SNAPSHOT] u=%d seq=%d symbol=%s\\n", u, msg.Seq, msg.Symbol)\n            continue\n        }\n\n        if book.LastU != 0 && u != book.LastU+1 {\n            log.Printf("[WARN] u jump: lastU=%d newU=%d \u2013 consider resync", book.LastU, u)\n        }\n\n        if pkgType == quote.PkgTypeEnum_SNAPSHOT {\n            book.Asks.SnapshotFrom(asks)\n            book.Bids.SnapshotFrom(bids)\n        } else {\n            for _, lv := range asks {\n                book.Asks.Apply(lv[0], lv[1])\n            }\n            for _, lv := range bids {\n                book.Bids.Apply(lv[0], lv[1])\n            }\n        }\n\n        book.LastU = u\n        bestBid := book.Bids.BestBid()\n        bestAsk := book.Asks.BestAsk()\n        fmt.Printf("u=%d pkgType=%d bestBid=%.5f bestAsk=%.5f\\n", u, pkgType, bestBid, bestAsk)\n    }\n}\n\n// helpers (optional, depending on ws framing)\nfunc isDeflatedFrame(data []byte) bool {\n    // placeholder: detect by protocol; many setups know from WS sub-protocol\n    return false\n}\n\nfunc inflate(data []byte) ([]byte, error) {\n    r := flate.NewReader(bytes.NewReader(data))\n    defer r.Close()\n\n    var out bytes.Buffer\n    if _, err := out.ReadFrom(r); err != nil {\n        return nil, err\n    }\n    return out.Bytes(), nil\n}\n')))}u.isMDXComponent=!0}}]);