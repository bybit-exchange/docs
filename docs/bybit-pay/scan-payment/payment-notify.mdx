---
title: Payment Notify
sidebar_label: Payment Notify
sidebar_position: 3
---
### Authentication
- Share the IP whitelist with each other;
- Bybit Pay will encrypt the callbacks via RSA_SHA256. Partners can provide the public key, sign date put in result head. For details, please see [Signature Algorithm](#signature-algorithm)

### HTTP Request
Method: `POST`<br/> 
URL: provide the callback url in the [Create Payment](create-payment) request parameter `webhookUrl`

### Header
| Parameter | Comments|
|:-----|----- |
|Content-Type |application/json|
|timestamp |Current timestamp|
|signature |Generated by [Signature Algorithm](#signature-algorithm)|

### Callback Request Parameters
| Parameter | Type | Comments|
|:----- |:-----|----- |
|paymentType |string |Payment type  <li>`E_COMMERCE`: Bybit QR Pay for e-commerce</li><li>`E_COMMERCE_REFUND`: Bybit QR Pay refund for e-commerce</li>|
| |&lt;[PayOrderType](../data-model/pay-order)&gt; |Retured when "paymentType"=`E_COMMERCE`|
| |&lt;[RefundOrderType](../data-model/refund-order)&gt; |Returned when "paymentType"=`E_COMMERCE_REFUND`|

### Signature Algorithm
#### Encrypt
1. Sort all fields in ascending alphabetical order by field name(key) in key=value format.
2. Generate a second timestamp and append it to the end of the sorted string in the format &amp;timestamp=${timestamp}
3. Encrypt string content with sha256 and sign with PKCS1V15,1024
4. Encode the encrypted bytes in base64

For example, we sign the following data. The timestamp is `1740541514`, the RSA key is
```shell
-----The following key pairs are for testing only-----
-----BEGIN RSA PUBLIC KEY-----
MIGJAoGBAOFSnhqtu40TOtok+yXeB+O76PXb/VAJU4Yih6hViOdSGd7imWmCSZyP
psl3TmXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf+AxlKYMj8OQ
AgDPmZG1a5ydFrje4PLytC7sUw3GP4TTk8xg6iMHmYPdRDv7AEWdAgMBAAE=
-----END RSA PUBLIC KEY-----

-----BEGIN RSA PRIVATE KEY-----
MIICXwIBAAKBgQDhUp4arbuNEzraJPsl3gfju+j12/1QCVOGIoeoVYjnUhne4plp
gkmcj6bJd05i4VKAfq082AXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
DI/DkAIAz5mRtWucnRa43XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
AoGBAIqpeCi83516xw32XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
axzIwyfWTTATWbiCS9sqXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
6gOQYu8kzRqCzqvyMNdAHXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
e/Gxi7qhuIKz0mvfA/yieXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
3IBIdV/CbwJBAOQcsOPf+XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
/5V9zdim+hPq+9cvsqO7dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
MY4uV8noiqDRf/pvAkyMMXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
15eWR4jEoXMIFkd7Onc6tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Bnj6KW1fk+UM29dUDjmTqXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
IavMyjrhDKyBGZ0mI6eoREaC4bxl31RRkYtg9mNeU3TxsBM=
-----END RSA PRIVATE KEY-----
```

```json
{
    "paymentType": "E_COMMERCE",
    "merchantId": "12",
    "clientId": "xx",
    "merchantTradeNo": "123456",
    "payId": "123456",
    "status": "INIT",
    "amount": "100",
    "currency": "USDT",
    "currencyType": "crypto",
    "createTime": 1740488831,
    "paymentTime": 1740488831,
    "finishTime": 1740488831
}
```
1. Sort all fields in ascending alphabetical order by field name(key) in key=value format.
```json
amount=100&clientId=xx&createTime=1740488831000&currency=USDT&currencyType=crypto&finishTime=1740488831000&merchantId=12&merchantTradeNo=123456&payId=123456&paymentTime=1740488831000&paymentType=E_COMMERCE&status=INIT
```
2. Generate a second timestamp and append it to the end of the sorted string in the format &amp;timestamp=${timestamp}
```json
amount=100&clientId=xx&createTime=1740488831000&currency=USDT&currencyType=crypto&finishTime=1740488831000&merchantId=12&merchantTradeNo=123456&payId=123456&paymentTime=1740488831000&paymentType=E_COMMERCE&status=INIT&timestamp=1740541514
```
3. Encrypt string content with sha256 and sign with PKCS1V15,1024
4. Encode the encrypted bytes in base64
```shell
NgDZLZCVBdma904hzZXmU+fQ7dr7z7muZkuwAbDnibLXXXXXXXXXXXXgmzad58LfRtLXGlkNPXXXXXXXXXXX9jNYd6gxp7j0Mlh0vQlQCIb2283DQ3wbZDphilvXXXXXXXXXXXXX2IIBelYBBw39U=
```
#### Decrypt
1. Get `timestamp`, `signature` from request header.
2. Get request body and unmarshal to structure or map structure.
3. Sort all fields in ascending alphabetical order by field name(key) in key=value format.
4. Generate a second timestamp and append it to the end of the sorted string in the format &amp;timestamp=${timestamp}.
5. decode the signature bytes from base64.
6. Encrypt string content with sha256 and verify signature  base PKCS1V15,1024.
For example, we provided the following data.
``` shell
NgDZLZCVBdma904hzZXmU+fQ7dr7z7muZkuwAbDnibLXXXXXXXXXXXXgmzad58LfRtLXGlkNPXXXXXXXXXXX9jNYd6gxp7j0Mlh0vQlQCIb2283DQ3wbZDphilvXXXXXXXXXXXXX2IIBelYBBw39U=
```
The timestamp is `1740541514`, the RSA key is
```shell
-----The following key pairs are for testing only-----
-----BEGIN RSA PUBLIC KEY-----
MIGJAoGBAOFSnhqtu40TOtok+yXeB+O76PXb/VAJU4Yih6hViOdSGd7imWmCSZyP
psl3TmXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXf+AxlKYMj8OQ
AgDPmZG1a5ydFrje4PLytC7sUw3GP4TTk8xg6iMHmYPdRDv7AEWdAgMBAAE=
-----END RSA PUBLIC KEY-----

-----BEGIN RSA PRIVATE KEY-----
MIICXwIBAAKBgQDhUp4arbuNEzraJPsl3gfju+j12/1QCVOGIoeoVYjnUhne4plp
gkmcj6bJd05i4VKAfq082AXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
DI/DkAIAz5mRtWucnRa43XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
AoGBAIqpeCi83516xw32XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
axzIwyfWTTATWbiCS9sqXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
6gOQYu8kzRqCzqvyMNdAHXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
e/Gxi7qhuIKz0mvfA/yieXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
3IBIdV/CbwJBAOQcsOPf+XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
/5V9zdim+hPq+9cvsqO7dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
MY4uV8noiqDRf/pvAkyMMXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
15eWR4jEoXMIFkd7Onc6tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Bnj6KW1fk+UM29dUDjmTqXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
IavMyjrhDKyBGZ0mI6eoREaC4bxl31RRkYtg9mNeU3TxsBM=
-----END RSA PRIVATE KEY-----
```
1. Sort all fields in ascending alphabetical order by field name(key) in key=value format.
```json
amount=100&clientId=xx&createTime=1740488831000&currency=USDT&currencyType=crypto&finishTime=1740488831000&merchantId=12&merchantTradeNo=123456&payId=123456&paymentTime=1740488831000&paymentType=E_COMMERCE&status=INIT
```
2. Generate a second timestamp and append it to the end of the sorted string in the format &amp;timestamp=${timestamp}
```json
amount=100&clientId=xx&createTime=1740488831000&currency=USDT&currencyType=crypto&finishTime=1740488831000&merchantId=12&merchantTradeNo=123456&payId=123456&paymentTime=1740488831000&paymentType=E_COMMERCE&status=INIT&timestamp=1740541514
```
3. decode the signature bytes from base64
4. Encrypt string content with sha256 and verify signature  base PKCS1V15,1024


### Request Example
#### Callback Pay Order
```http
POST ${webhook url} HTTP/1.1
Host: XXXXX
timestamp: XXXXX
signature: XXXXX
Content-Type: application/json

{
    "paymentType": "E_COMMERCE",
    "merchantId": "12",
    "clientId": "xx",
    "merchantTradeNo": "123456",
    "payId": "123456",
    "status": "INIT",
    "amount": "100",
    "currency": "USDT",
    "currencyType": "crypto",
    "createTime": 1740488831,
    "paymentTime": 1740488831,
    "finishTime": 1740488831
}
```

#### Callback Refund Order
```http
POST ${webhook url} HTTP/1.1
Host: XXXXX
timestamp: XXXXX
signature: XXXXX
Content-Type: application/json

{
    "paymentType": "E_COMMERCE_REFUND",
    "refundId": "123",
    "refundType": "MERCHNT_SELF_REFUND",
    "merchantTradeNo": "123456",
    "merchantRefundNo": "123456",
    "payId": "123456",
    "refundStatus": "REFUND_SUCCESS",
    "amount": "17399",
    "createTime": 1740488831
}
```