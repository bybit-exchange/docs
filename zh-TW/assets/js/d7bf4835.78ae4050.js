"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[2812],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(t),m=i,c=u["".concat(s,".").concat(m)]||u[m]||f[m]||a;return t?r.createElement(c,l(l({ref:n},d),{},{components:t})):r.createElement(c,l({ref:n},d))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,l=new Array(a);l[0]=u;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<a;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},31617:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=t(87462),i=(t(67294),t(3905));const a={title:"SBE Public Trade \u63a5\u5165\u6307\u5357",sidebar_label:"SBE Public Trade \u63a5\u5165\u6307\u5357",sidebar_position:3},l=void 0,o={unversionedId:"v5/sbe/sbe-public-trade/sbe-public-trade",id:"v5/sbe/sbe-public-trade/sbe-public-trade",title:"SBE Public Trade \u63a5\u5165\u6307\u5357",description:"\u7e3d\u89bd",source:"@site/i18n/zh-TW/docusaurus-plugin-content-docs/current/v5/sbe/sbe-public-trade/sbe-public-trade.mdx",sourceDirName:"v5/sbe/sbe-public-trade",slug:"/v5/sbe/sbe-public-trade/",permalink:"/docs/zh-TW/v5/sbe/sbe-public-trade/",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"SBE Public Trade \u63a5\u5165\u6307\u5357",sidebar_label:"SBE Public Trade \u63a5\u5165\u6307\u5357",sidebar_position:3},sidebar:"v5SideBar",previous:{title:"SBE Level 50 \u63a5\u5165\u6307\u5357",permalink:"/docs/zh-TW/v5/sbe/level-50/sbe-level-50"},next:{title:"\u8a02\u95b1WebSocket",permalink:"/docs/zh-TW/v5/ws/connect"}},s={},p=[{value:"\u7e3d\u89bd",id:"\u7e3d\u89bd",level:2},{value:"\u6d41\u7a0b",id:"\u6d41\u7a0b",level:2},{value:"Ping / Pong (JSON \u63a7\u5236 frame)",id:"ping--pong-json-\u63a7\u5236-frame",level:3},{value:"\u8a02\u95b1",id:"\u8a02\u95b1",level:3},{value:"SBE XML \u6a21\u677f (Public Trade)",id:"sbe-xml-\u6a21\u677f-public-trade",level:2},{value:"\u6b04\u4f4d\u53c3\u8003",id:"\u6b04\u4f4d\u53c3\u8003",level:2},{value:"\u6bcf\u500b tradeItemsi \u689d\u76ee",id:"\u6bcf\u500b-tradeitemsi-\u689d\u76ee",level:3},{value:"SideType",id:"sidetype",level:4},{value:"BoolEnum",id:"boolenum",level:4},{value:"\u63a5\u5165\u793a\u4f8b",id:"\u63a5\u5165\u793a\u4f8b",level:2},{value:"Python",id:"python",level:3},{value:"Golang",id:"golang",level:3}],d={toc:p};function f(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"\u7e3d\u89bd"},"\u7e3d\u89bd"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Channel:")," \u50c5\u652f\u63f4MMWS\u57df\u540d"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"WSURL:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"wss://<your-public-stream-host>.bybit-aws.com/v5/public-sbe/<category>"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Topic:")," ",(0,i.kt)("inlineCode",{parentName:"li"},"publicTrade.sbe.<symbol>"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Format:")," SBE \u4e8c\u9032\u5236 frame (",(0,i.kt)("inlineCode",{parentName:"li"},"opcode = 2"),"), little-endian."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"\u63a8\u9001\u983b\u7387"),":\u5373\u6642  "),(0,i.kt)("li",{parentName:"ul"},"\u8a0a\u606f\u6703\u4f9d\u7167\u6bcf\u500b\u5546\u54c1(symbol)\u7fa4\u7d44\u4ee5\u9806\u5e8f\u65b9\u5f0f\u50b3\u905e\u3002\u55ae\u4e00\u5c01\u5305\u53ef\u80fd\u5305\u542b 1\u20131024 \u7b46\u6210\u4ea4\u8cc7\u8a0a\u3002")),(0,i.kt)("h2",{id:"\u6d41\u7a0b"},"\u6d41\u7a0b"),(0,i.kt)("h3",{id:"ping--pong-json-\u63a7\u5236-frame"},"Ping / Pong (JSON \u63a7\u5236 frame)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Send Ping")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"req_id": "100001", "op": "ping"}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Receive Pong")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"success": true,"ret_msg": "pong","conn_id": "xxxxx-xx","req_id": "","op": "ping"}\n')),(0,i.kt)("h3",{id:"\u8a02\u95b1"},"\u8a02\u95b1"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Topic format: ",(0,i.kt)("inlineCode",{parentName:"li"},"publicTrade.sbe.<symbol>"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u8a02\u95b1\u793a\u4f8b")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"op": "subscribe","req_id":"100001","args": ["publicTrade.sbe.BTCUSDT"]}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u8a02\u95b1\u56de\u5831")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{"success":true,"ret_msg":"","conn_id":"d5phu6rboasumi7uds7g-223s","req_id":"100001","op":"subscribe"}\n')),(0,i.kt)("h2",{id:"sbe-xml-\u6a21\u677f-public-trade"},"SBE XML \u6a21\u677f (Public Trade)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8"?>\n<sbe:messageSchema xmlns:sbe="http://fixprotocol.io/2016/sbe" xmlns:mbx="https://bybit-exchange.github.io/docs/v5/intro" package="quote.sbe" id="1" version="0" semanticVersion="1.0.0" description="Bybit market data streams SBE message schema" byteOrder="littleEndian" headerType="messageHeader">\n  <types>\n    <composite name="messageHeader" description="Template ID and length of message root">\n <type name="blockLength" primitiveType="uint16"/>\n <type name="templateId" primitiveType="uint16"/>\n <type name="schemaId" primitiveType="uint16"/>\n <type name="version" primitiveType="uint16"/>\n    </composite>\n    <composite name="varString8" description="Variable length UTF-8 string.">\n <type name="length" primitiveType="uint8"/>\n <type name="varData" length="0" primitiveType="uint8" semanticType="String" characterEncoding="UTF-8"/>\n    </composite>\n    <enum name="SideType" encodingType="uint8">\n <validValue name="UNKNOWN">0</validValue>\n <validValue name="BUY">1</validValue>\n <validValue name="SELL">2</validValue>\n <validValue name="NON_REPRESENTABLE">254</validValue>\n    </enum>\n    <enum name="BoolEnum" encodingType="uint8">\n <validValue name="FALSE">0</validValue>\n <validValue name="TRUE">1</validValue>\n <validValue name="NON_REPRESENTABLE">254</validValue>\n    </enum>\n  </types>\n  \x3c!-- Stream event for "publicTrade.sbe.<symbol>" channel --\x3e\n  <sbe:message name="PublicTradeEvent" id="20002">\n    <field id="1" name="ts" type="int64" description="The timestamp in microseconds that the system generates the data"/>\n    <field id="2" name="priceExponent" type="int8" description="Price exponent for decimal point positioning"/>\n    <field id="3" name="sizeExponent" type="int8" description="Size exponent for decimal point positioning"/>\n    <group id="40" name="tradeItems" dimensionType="groupSize16Encoding" description="trade items">\n <field id="1" name="fillTime" type="int64" description="The timestamp in microseconds that the order is filled"/>\n <field id="2" name="price" type="int64" description="Price mantissa"/>\n <field id="3" name="size" type="int64" description="Size mantissa"/>\n <field id="4" name="seq" type="int64" description="Cross sequence ID"/>\n <field id="5" name="side" type="SideType" description="Side of taker"/>\n <field id="6" name="isBlockTrade" type="BoolEnum" description="Whether it is a block trade order or not"/>\n <field id="7" name="isRPI" type="BoolEnum" description="Whether it is a RPI trade or not"/>\n <field id="8" name="execId" type="int64" description="Trade ID"/>\n <data id="100" name="execIdString" type="varString8"/>\n    </group>\n    <data id="55" name="symbol" type="varString8"/>\n  </sbe:message>\n</sbe:messageSchema>\n')),(0,i.kt)("h2",{id:"\u6b04\u4f4d\u53c3\u8003"},"\u6b04\u4f4d\u53c3\u8003"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Message:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"PublicTradeEvent")," (id = 20002)"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"\u6b04\u4f4d\u540d\u7a31"),(0,i.kt)("th",{parentName:"tr",align:null},"ID"),(0,i.kt)("th",{parentName:"tr",align:null},"SBE \u578b\u5225"),(0,i.kt)("th",{parentName:"tr",align:null},"\u55ae\u4f4d / \u683c\u5f0f"),(0,i.kt)("th",{parentName:"tr",align:null},"\u5099\u8a3b"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ts"),(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"\xb5s"),(0,i.kt)("td",{parentName:"tr",align:null},"\u63a8\u9001\u5074(dispatcher)\u7522\u751f\u8cc7\u6599\u7684\u7cfb\u7d71\u6642\u9593\u6233")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"priceExponent"),(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"int8"),(0,i.kt)("td",{parentName:"tr",align:null},"exponent"),(0,i.kt)("td",{parentName:"tr",align:null},"\u50f9\u683c\u7684\u5c0f\u6578\u4f4d\u6578\u3002\u986f\u793a\u50f9\u683c = priceMantissa \xd7 10^",(0,i.kt)("inlineCode",{parentName:"td"},"priceExponent"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sizeExponent"),(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"int8"),(0,i.kt)("td",{parentName:"tr",align:null},"exponent"),(0,i.kt)("td",{parentName:"tr",align:null},"\u6578\u91cf\u7684\u5c0f\u6578\u4f4d\u6578\u3002\u986f\u793a\u6578\u91cf = sizeMantissa \xd7 10^",(0,i.kt)("inlineCode",{parentName:"td"},"sizeExponent"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tradeItems"),(0,i.kt)("td",{parentName:"tr",align:null},"40"),(0,i.kt)("td",{parentName:"tr",align:null},"group",(0,i.kt)("br",null),"(",(0,i.kt)("inlineCode",{parentName:"td"},"groupSize16Encoding"),")"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"\u91cd\u8907\u7684\u6210\u4ea4\u9805\u76ee(Repeating trade items)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"symbol"),(0,i.kt)("td",{parentName:"tr",align:null},"55"),(0,i.kt)("td",{parentName:"tr",align:null},"varString8"),(0,i.kt)("td",{parentName:"tr",align:null},"UTF-8"),(0,i.kt)("td",{parentName:"tr",align:null},"1-byte \u9577\u5ea6 + bytes,\u4f8b\u5982:",(0,i.kt)("inlineCode",{parentName:"td"},'0x07 "BTCUSDT"'))))),(0,i.kt)("h3",{id:"\u6bcf\u500b-tradeitemsi-\u689d\u76ee"},"\u6bcf\u500b tradeItems","[i]"," \u689d\u76ee"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"\u6b04\u4f4d(id)"),(0,i.kt)("th",{parentName:"tr",align:null},"\u578b\u5225"),(0,i.kt)("th",{parentName:"tr",align:null},"\u8aaa\u660e"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"fillTime(1)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"\u6210\u4ea4\u64ae\u5408\u6642\u9593\u6233(\xb5s)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"price(2)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5957\u7528 priceExponent\u3002\u986f\u793a\u50f9\u683c = ",(0,i.kt)("inlineCode",{parentName:"td"},"price \xd7 10^priceExponent"),"\u3002")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"size(3)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"\u5957\u7528 sizeExponent\u3002\u986f\u793a\u6578\u91cf = ",(0,i.kt)("inlineCode",{parentName:"td"},"size \xd7 10^sizeExponent"),"\u3002")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"seq(4)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"\u64ae\u5408\u5e8f\u5217 ID")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"side(5)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#sidetype"},"SideType"),"(uint8)"),(0,i.kt)("td",{parentName:"tr",align:null},"taker\u55ae\u65b9\u5411")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"isBlockTrade(6)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#boolenum"},"BoolEnum"),"(uint8)"),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f\u5426\u70ba\u5927\u5b97\u4ea4\u6613(0 = \u975e blockTrade,1 = blockTrade)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"isRPI(7)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#boolenum"},"BoolEnum"),"(uint8)"),(0,i.kt)("td",{parentName:"tr",align:null},"\u662f\u5426\u70ba RPI(0 = \u975e RPI,1 = RPI)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"execId(8)"),(0,i.kt)("td",{parentName:"tr",align:null},"int64"),(0,i.kt)("td",{parentName:"tr",align:null},"\u6210\u4ea4 ID")))),(0,i.kt)("h4",{id:"sidetype"},"SideType"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0"),": UNKOWN"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1"),": BUY"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2"),": SELL"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"254"),": NON_REPRESENTABLE")),(0,i.kt)("h4",{id:"boolenum"},"BoolEnum"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0"),": FALSE"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1"),": TRUE"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"254"),": NON_REPRESENTABLE")),(0,i.kt)("h2",{id:"\u63a5\u5165\u793a\u4f8b"},"\u63a5\u5165\u793a\u4f8b"),(0,i.kt)("h3",{id:"python"},"Python"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import json\nimport struct\nimport websocket\nfrom typing import Tuple\n\nWS_URL = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\nSYMBOL = "BTCUSDT"\nTOPIC = f"publicTrade.sbe.{SYMBOL}"\n\n\n# ---------------- SBE helpers ----------------\ndef apply_exp(mantissa: int, exp: int) -> float:\n    # display = mantissa * 10^exp\n    # exp can be negative\n    return mantissa * (10.0**exp)\n\n\ndef read_varstring8(buf: bytes, off: int) -> Tuple[str, int]:\n    if off + 1 > len(buf):\n        raise ValueError("varString8: missing length")\n\n    ln = buf[off]\n    off += 1\n\n    if off + ln > len(buf):\n        raise ValueError("varString8: out of range")\n\n    s = buf[off : off + ln].decode("utf-8", errors="replace")\n    off += ln\n    return s, off\n\n\ndef parse_public_trade_event(buf: bytes) -> dict:\n    # messageHeader: <HHHH\n    if len(buf) < 8:\n        raise ValueError("too short for header")\n\n    block_len, template_id, schema_id, version = struct.unpack_from("<HHHH", buf, 0)\n    off = 8\n\n    if template_id != 20002:\n        raise ValueError(f"unexpected templateId={template_id}")\n\n    # fixed fields: ts(int64), priceExp(int8), sizeExp(int8)\n    if len(buf) < off + 8 + 1 + 1:\n        raise ValueError("too short for fixed fields")\n\n    ts = struct.unpack_from("<q", buf, off)[0]\n    off += 8\n\n    price_exp = struct.unpack_from("<b", buf, off)[0]\n    off += 1\n\n    size_exp = struct.unpack_from("<b", buf, off)[0]\n    off += 1\n\n    # group header: blockLength(uint16), numInGroup(uint16)\n    if len(buf) < off + 4:\n        raise ValueError("too short for group header")\n\n    grp_block_len, num_in_group = struct.unpack_from("<HH", buf, off)\n    off += 4\n\n    trades = []\n    for _ in range(num_in_group):\n        entry_start = off\n\n        # Parse fields in-order (don\u2019t assume padding; only skip remaining bytes up to grp_block_len)\n        fill_time = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        price_m = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        size_m = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        seq = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        side = struct.unpack_from("<B", buf, off)[0]\n        off += 1\n\n        is_block = struct.unpack_from("<B", buf, off)[0]\n        off += 1\n\n        is_rpi = struct.unpack_from("<B", buf, off)[0]\n        off += 1\n\n        exec_id = struct.unpack_from("<q", buf, off)[0]\n        off += 8\n\n        # Skip any future extension bytes in fixed part\n        fixed_consumed = off - entry_start\n        if fixed_consumed < grp_block_len:\n            off += grp_block_len - fixed_consumed\n        elif fixed_consumed > grp_block_len:\n            # schema mismatch vs blockLength\n            raise ValueError(\n                f"group blockLength too small: {grp_block_len} < {fixed_consumed}"\n            )\n\n        exec_id_str, off = read_varstring8(buf, off)\n\n        trades.append(\n            {\n                "fillTime": fill_time,\n                "priceMantissa": price_m,\n                "sizeMantissa": size_m,\n                "price": apply_exp(price_m, price_exp),\n                "size": apply_exp(size_m, size_exp),\n                "seq": seq,\n                "side": side,\n                "isBlockTrade": bool(is_block),\n                "isRPI": bool(is_rpi),\n                "execId": exec_id,\n                "execIdString": exec_id_str,\n            }\n        )\n\n    symbol, off = read_varstring8(buf, off)\n\n    return {\n        "header": {\n            "blockLength": block_len,\n            "templateId": template_id,\n            "schemaId": schema_id,\n            "version": version,\n        },\n        "ts": ts,\n        "priceExponent": price_exp,\n        "sizeExponent": size_exp,\n        "symbol": symbol,\n        "tradeItems": trades,\n        "parsed_length": off,\n    }\n\n\n# ---------------- WS handlers ----------------\ndef on_open(ws):\n    ws.send(json.dumps({"op": "subscribe", "args": [TOPIC]}))\n    print("subscribed:", TOPIC)\n\n\ndef on_message(ws, message):\n    if isinstance(message, (bytes, bytearray)):\n        evt = parse_public_trade_event(message)\n\n        # print first trade only (example)\n        if evt["tradeItems"]:\n            t0 = evt["tradeItems"][0]\n            print(\n                evt["symbol"],\n                "trades=",\n                len(evt["tradeItems"]),\n                "first:",\n                t0["price"],\n                "@",\n                t0["size"],\n                "seq=",\n                t0["seq"],\n            )\n    else:\n        print("TEXT:", message)\n\n\ndef on_error(ws, err):\n    print("WS error:", err)\n\n\ndef on_close(ws, *_):\n    print("closed")\n\n\nif __name__ == "__main__":\n    websocket.enableTrace(False)\n    ws = websocket.WebSocketApp(\n        WS_URL,\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n    )\n    ws.run_forever(ping_interval=20, ping_timeout=10)  \n')),(0,i.kt)("h3",{id:"golang"},"Golang"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n        "encoding/binary"\n        "encoding/json"\n        "fmt"\n        "log"\n        "math"\n        "time"\n\n        "github.com/gorilla/websocket"\n)\n\nconst (\n        WSURL  = "wss://stream-testnet.bybits.org/v5/public-sbe/spot"\n        Symbol = "BTCUSDT"\n        Topic  = "publicTrade.sbe." + Symbol\n)\n\nfunc applyExp(mantissa int64, exp int8) float64 {\n        return float64(mantissa) * math.Pow10(int(exp))\n}\n\nfunc readVarString8(buf []byte, off int) (string, int, error) {\n        if off+1 > len(buf) {\n                return "", off, fmt.Errorf("varString8: missing length")\n        }\n        ln := int(buf[off])\n        off++\n        if off+ln > len(buf) {\n                return "", off, fmt.Errorf("varString8: out of range")\n        }\n        s := string(buf[off : off+ln])\n        off += ln\n        return s, off, nil\n}\n\ntype TradeItem struct {\n        FillTime     int64   `json:"fillTime"`\n        PriceMant    int64   `json:"priceMantissa"`\n        SizeMant     int64   `json:"sizeMantissa"`\n        Price        float64 `json:"price"`\n        Size         float64 `json:"size"`\n        Seq          int64   `json:"seq"`\n        Side         uint8   `json:"side"`\n        IsBlockTrade bool    `json:"isBlockTrade"`\n        IsRPI        bool    `json:"isRPI"`\n        ExecID       int64   `json:"execId"`\n        ExecIDString string  `json:"execIdString"`\n}\n\ntype PublicTradeEvent struct {\n        Header struct {\n                BlockLength uint16 `json:"blockLength"`\n                TemplateID  uint16 `json:"templateId"`\n                SchemaID    uint16 `json:"schemaId"`\n                Version     uint16 `json:"version"`\n        } `json:"header"`\n\n        Ts            int64       `json:"ts"`\n        PriceExponent int8        `json:"priceExponent"`\n        SizeExponent  int8        `json:"sizeExponent"`\n        TradeItems    []TradeItem `json:"tradeItems"`\n        Symbol        string      `json:"symbol"`\n        ParsedLength  int         `json:"parsed_length"`\n}\n\nfunc parsePublicTradeEvent(buf []byte) (*PublicTradeEvent, error) {\n        if len(buf) < 8 {\n                return nil, fmt.Errorf("too short for header")\n        }\n        off := 0\n        blk := binary.LittleEndian.Uint16(buf[off : off+2])\n        tid := binary.LittleEndian.Uint16(buf[off+2 : off+4])\n        sid := binary.LittleEndian.Uint16(buf[off+4 : off+6])\n        ver := binary.LittleEndian.Uint16(buf[off+6 : off+8])\n        off += 8\n\n        if tid != 20002 {\n                return nil, fmt.Errorf("unexpected templateId=%d", tid)\n        }\n        if off+8+1+1 > len(buf) {\n                return nil, fmt.Errorf("too short for fixed fields")\n        }\n        ts := int64(binary.LittleEndian.Uint64(buf[off : off+8]))\n        off += 8\n        priceExp := int8(buf[off])\n        off++\n        sizeExp := int8(buf[off])\n        off++\n\n        // group header\n        if off+4 > len(buf) {\n                return nil, fmt.Errorf("too short for group header")\n        }\n        grpBlockLen := binary.LittleEndian.Uint16(buf[off : off+2])\n        numInGroup := binary.LittleEndian.Uint16(buf[off+2 : off+4])\n        off += 4\n\n        items := make([]TradeItem, 0, int(numInGroup))\n        for i := 0; i < int(numInGroup); i++ {\n                entryStart := off\n\n                needMin := 8 + 8 + 8 + 8 + 1 + 1 + 1 + 8\n                if off+needMin > len(buf) {\n                        return nil, fmt.Errorf("too short for trade entry %d", i)\n                }\n\n                fillTime := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n                priceM := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n                sizeM := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n                seq := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n\n                side := uint8(buf[off]); off++\n                isBlock := uint8(buf[off]); off++\n                isRpi := uint8(buf[off]); off++\n\n                execID := int64(binary.LittleEndian.Uint64(buf[off : off+8])); off += 8\n\n                fixedConsumed := off - entryStart\n                if fixedConsumed < int(grpBlockLen) {\n                        off += int(grpBlockLen) - fixedConsumed\n                } else if fixedConsumed > int(grpBlockLen) {\n                        return nil, fmt.Errorf("group blockLength too small: %d < %d", grpBlockLen, fixedConsumed)\n                }\n\n                execIDStr, off2, err := readVarString8(buf, off)\n                if err != nil {\n                        return nil, err\n                }\n                off = off2\n\n                items = append(items, TradeItem{\n                        FillTime:     fillTime,\n                        PriceMant:    priceM,\n                        SizeMant:     sizeM,\n                        Price:        applyExp(priceM, priceExp),\n                        Size:         applyExp(sizeM, sizeExp),\n                        Seq:          seq,\n                        Side:         side,\n                        IsBlockTrade: isBlock != 0,\n                        IsRPI:        isRpi != 0,\n                        ExecID:       execID,\n                        ExecIDString: execIDStr,\n                })\n        }\n\n        symbol, off2, err := readVarString8(buf, off)\n        if err != nil {\n                return nil, err\n        }\n        off = off2\n\n        evt := &PublicTradeEvent{\n                Ts:            ts,\n                PriceExponent: priceExp,\n                SizeExponent:  sizeExp,\n                TradeItems:    items,\n                Symbol:        symbol,\n                ParsedLength:  off,\n        }\n        evt.Header.BlockLength = blk\n        evt.Header.TemplateID = tid\n        evt.Header.SchemaID = sid\n        evt.Header.Version = ver\n        return evt, nil\n}\n\nfunc main() {\n        d := websocket.Dialer{HandshakeTimeout: 10 * time.Second}\n        c, _, err := d.Dial(WSURL, nil)\n        if err != nil {\n                log.Fatal(err)\n        }\n        defer c.Close()\n\n        sub, _ := json.Marshal(map[string]any{"op": "subscribe", "args": []string{Topic}})\n        if err := c.WriteMessage(websocket.TextMessage, sub); err != nil {\n                log.Fatal(err)\n        }\n        log.Println("subscribed:", Topic)\n\n        for {\n                mt, msg, err := c.ReadMessage()\n                if err != nil {\n                        log.Fatal(err)\n                }\n                if mt == websocket.BinaryMessage {\n                        evt, err := parsePublicTradeEvent(msg)\n                        if err != nil {\n                                log.Println("decode error:", err)\n                                continue\n                        }\n                        if len(evt.TradeItems) > 0 {\n                                t0 := evt.TradeItems[0]\n                                log.Printf("%s trades=%d first=%.8f@%.8f seq=%d",\n                                        evt.Symbol, len(evt.TradeItems), t0.Price, t0.Size, t0.Seq)\n                        }\n                } else {\n                        log.Println("TEXT:", string(msg))\n                }\n        }\n}\n')))}f.isMDXComponent=!0}}]);